{
    "[DP] Convex Hull Trick": {
        "body": [
            "LL dp(int n) {",
            "    LL res=0,pre=0;",
            "    vector<pair<LL,LL>> q(1);",
            "    for(int i=1,idx=0;i<=n;i++) {",
            "        ",
            "        // assert(idx<q.size());",
            "        auto [x,y]=q[idx];",
            "        LL k=0.0;",
            "        LL b=y-k*x;",
            "        while(idx+1<q.size()) {",
            "            auto [x,y]=q[idx+1];",
            "            if(y-k*x<=b) {",
            "                b=y-k*x;",
            "                idx++;",
            "            }",
            "            else break;",
            "        }",
            "        ",
            "        res=0.0;",
            "        x=0.0;",
            "        y=0.0;",
            "    ",
            "        while(q.size()>=2) {",
            "            auto [xl,yl]=q[q.size()-2];",
            "            auto [xr,yr]=q[q.size()-1];",
            "            if((y-yr)*(x-xl)<=(y-yl)*(x-xr)) q.pop_back();",
            "            else break;",
            "        }",
            "        q.emplace_back(x,y);",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Convex Hull Trick",
        "prefix": "#convex_hull_trick"
    },
    "[DS] 01-Trie": {
        "body": [
            "template<typename I,int H=sizeof(I)*8-1-is_signed<I>()>",
            "struct BinaryTrie {",
            "    struct Node {",
            "        int ch[2];",
            "        int cnt;",
            "    };",
            "    vector<Node> tr;",
            "",
            "    int new_node() {",
            "        tr.push_back({});",
            "        return tr.size()-1;",
            "    }",
            "",
            "    void insert(int v) {",
            "        for(int i=H,u=0;i>=0;i--) {",
            "            bool x=v>>i&1;",
            "            if(!tr[u].ch[x]) tr[u].ch[x]=new_node();",
            "            u=tr[u].ch[x];",
            "            tr[u].cnt++;",
            "        }",
            "    }",
            "",
            "    void erase(int v) {",
            "        for(int i=H,u=0;i>=0;i--) {",
            "            bool x=v>>i&1;",
            "            u=tr[u].ch[x];",
            "            tr[u].cnt--;",
            "        }",
            "    }",
            "",
            "    I xor_max(int v) {",
            "        I res{};",
            "        for(int i=H,u=0;i>=0;i--) {",
            "            bool x=v>>i&1^1;",
            "            if(tr[tr[u].ch[x]].cnt) {",
            "                res|=1<<i;",
            "                u=tr[u].ch[x];",
            "            }",
            "            else u=tr[u].ch[x^1];",
            "        }",
            "        return res;",
            "    }",
            "",
            "    I xor_min(int v) {",
            "        I res{};",
            "        for(int i=H,u=0;i>=0;i--) {",
            "            bool x=v>>i&1;",
            "            if(tr[tr[u].ch[x]].cnt) u=tr[u].ch[x];",
            "            else {",
            "                res|=1<<i;",
            "                u=tr[u].ch[x^1];",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "",
            "    void clear() {",
            "        tr.clear();",
            "        new_node();",
            "    }",
            "",
            "    explicit BinaryTrie(int size=0) {",
            "        tr.reserve(size*(H+1));",
            "        clear();",
            "    }",
            "};"
        ],
        "description": "01-Trie",
        "prefix": "#binary_trie"
    },
    "[DS] Binary Search on Segment Tree (prefix/suffix)": {
        "body": [
            "template<class F>",
            "int find_first(int u,int l,int r,int x,int y,F check,Info &suf) {",
            "    if(l==r&&!check(info[u]+suf)) return -1;",
            "    if(l>=x&&r<=y&&check(info[u]+suf)) return suf=info[u]+suf,l;",
            "    pushdn(u);",
            "    int mid=(l+r)/2;",
            "    if(mid>=x&&mid<y) {",
            "        int res=find_first(rch,mid+1,r,x,y,check,suf);",
            "        if(res==mid+1) {",
            "            int t=find_first(lch,l,mid,x,y,check,suf);",
            "            if(t!=-1) res=t;",
            "        }",
            "        return res;",
            "    }",
            "    else if(mid>=x) return find_first(lch,l,mid,x,y,check,suf);",
            "    return find_first(rch,mid+1,r,x,y,check,suf);",
            "}",
            "template<class F> int find_first(int l,int r,F check,Info suf={}) {",
            "    l=max(l,rng_l),r=min(r,rng_r);",
            "    return l>r?-1:find_first(1,rng_l,rng_r,l,r,check,suf);",
            "}",
            "",
            "template<class F>",
            "int find_last(int u,int l,int r,int x,int y,F check,Info &pre) {",
            "    if(l==r&&!check(pre+info[u])) return -1;",
            "    if(l>=x&&r<=y&&check(pre+info[u])) return pre=pre+info[u],r;",
            "    pushdn(u);",
            "    int mid=(l+r)/2;",
            "    if(mid>=x&&mid<y) {",
            "        int res=find_last(lch,l,mid,x,y,check,pre);",
            "        if(res==mid) {",
            "            int t=find_last(rch,mid+1,r,x,y,check,pre);",
            "            if(t!=-1) res=t;",
            "        }",
            "        return res;",
            "    }",
            "    else if(mid>=x) return find_last(lch,l,mid,x,y,check,pre);",
            "    return find_last(rch,mid+1,r,x,y,check,pre);",
            "}",
            "template<class F> int find_last(int l,int r,F check,Info pre={}) {",
            "    l=max(l,rng_l),r=min(r,rng_r);",
            "    return l>r?-1:find_last(1,rng_l,rng_r,l,r,check,pre);",
            "}"
        ],
        "description": "",
        "prefix": "#segment_tree_binary_search"
    },
    "[DS] Chtholly Tree": {
        "body": [
            "struct ChthollyTree {",
            "    struct Node {",
            "        int l,r,v;",
            "        Node(int L,int R,int V) : l(L),r(R),v(V) {}",
            "        bool operator< (const Node &x) const {",
            "            return l<x.l;",
            "        }",
            "    };",
            "    set<Node> st;",
            "",
            "    auto split(int pos){",
            "        auto it=st.lower_bound(Node(pos,pos,0));",
            "        if(it!=st.end()&&it->l==pos) return it;",
            "        it=prev(it);",
            "        auto [l,r,v]=*it;",
            "        st.erase(it);",
            "        st.insert(Node(l,pos-1,v));",
            "        return st.insert(Node(pos,r,v)).first;",
            "    }",
            "",
            "    void assign(int l,int r,int v){",
            "        auto end=split(r+1),begin=split(l);",
            "        st.erase(begin,end);",
            "        st.insert(Node(l,r,v));",
            "    }",
            "} odt;"
        ],
        "description": "Chtholly Tree",
        "prefix": "#odt"
    },
    "[DS] Disjoint Union Set": {
        "body": [
            "struct DisjointUnionSet {",
            "    vector<int> fa,sz;",
            "",
            "    void init(int n) {",
            "        fa.resize(n+1);",
            "        sz.assign(n+1,1);",
            "        iota(fa.begin(), fa.end(), 0);",
            "    }",
            "",
            "    int find(int x) {",
            "        return x==fa[x]?x:fa[x]=find(fa[x]);",
            "    }",
            "",
            "    bool same(int x,int y) {",
            "        return find(x)==find(y);",
            "    }",
            "",
            "    bool join(int x,int y) {",
            "        x=find(x);",
            "        y=find(y);",
            "        if(x==y) return false;",
            "        // if(sz[x]<sz[y]) swap(x,y);",
            "        sz[x]+=sz[y];",
            "        fa[y]=x;",
            "        return true;",
            "    }",
            "",
            "    int size(int x) {",
            "        return sz[find(x)];",
            "    }",
            "",
            "    DisjointUnionSet() = default;",
            "    DisjointUnionSet(int n) { init(n); }",
            "} dsu;"
        ],
        "description": "并查集,按秩合并",
        "prefix": "#dsu"
    },
    "[DS] Fenwick Tree": {
        "body": [
            "template<typename T=int,T init=T()> struct Fenwick {",
            "    using F=function<void(T&,const T&)>;",
            "    F add;",
            "    vector<T> tr;",
            "",
            "    int lowbit(int x) { return x&(-x); }",
            "    void resize(int n) { tr.resize(n+2,init); }",
            "",
            "    void modify(int pos,T val) {",
            "        if(++pos<=0) return;",
            "        while(pos<tr.size()) add(tr[pos],val),pos+=lowbit(pos);",
            "    }",
            "",
            "    void reset(int pos) {",
            "        if(++pos<=0) return;",
            "        while(pos<tr.size()) tr[pos]=init,pos+=lowbit(pos);",
            "    }",
            "",
            "    T query(int pos) {",
            "        if(++pos<0) return {};",
            "        T res=init;",
            "        while(pos) add(res,tr[pos]),pos-=lowbit(pos);",
            "        return res;",
            "    }",
            "    ",
            "    explicit Fenwick(",
            "        int n,F add=[](T &x,const T &y) { x += y; })",
            "        : add(add) {",
            "        resize(n);",
            "    }",
            "};"
        ],
        "description": "FenwickTree",
        "prefix": "#fenwick"
    },
    "[DS] Heavy Path Decomposition": {
        "body": [
            "// ! don't confuse dfn id with node id",
            "namespace hpd {",
            "    using PII=pair<int,int>;",
            "    constexpr int N=1e5+10; // ***",
            "    int id[N],w[N],ori[N],cnt;",
            "    int dep[N],sz[N],top[N],p[N],hch[N];",
            "    vector<int> adj[N];",
            "",
            "    void dfs1(int u,int fa,int d) {",
            "        dep[u]=d,p[u]=fa,sz[u]=1;",
            "        for(int v:adj[u]) {",
            "            if(v==fa) continue;",
            "            dfs1(v,u,d+1);",
            "            sz[u]+=sz[v];",
            "            if(sz[hch[u]]<sz[v]) hch[u]=v;",
            "        }",
            "    }",
            "",
            "    void dfs2(int u,int t) {",
            "        id[u]=++cnt,ori[id[u]]=u,top[u]=t;",
            "        if(!hch[u]) return;",
            "        dfs2(hch[u],t);",
            "        for(int v:adj[u])",
            "            if(v!=p[u]&&v!=hch[u]) dfs2(v,v);",
            "    }",
            "",
            "    int lca(int x,int y) {",
            "        while(top[x]!=top[y]) {",
            "            if(dep[top[x]]<dep[top[y]]) swap(x,y);",
            "            x=p[top[x]];",
            "        }",
            "        if(dep[x]<dep[y]) swap(x,y);",
            "        return y;",
            "    }",
            "",
            "    vector<PII> decompose(int x,int y) {",
            "        vector<PII> res;",
            "        while(top[x]!=top[y]) {",
            "            if(dep[top[x]]<dep[top[y]]) swap(x,y);",
            "            res.emplace_back(id[top[x]],id[x]);",
            "            x=p[top[x]];",
            "        }",
            "        if(dep[x]<dep[y]) swap(x,y);",
            "        res.emplace_back(id[y],id[x]);",
            "        return res;",
            "    }",
            "",
            "    PII decompose(int x) {",
            "        return { id[x],id[x]+sz[x]-1 };",
            "    }",
            "",
            "    void init() {",
            "        dfs1(1,-1,1); dfs2(1,1);",
            "    }",
            "",
            "    void clear(int n) {",
            "        cnt=0;",
            "        fill(hch, hch+n+1, 0);",
            "    }",
            "}",
        ],
        "description": [
            "将树上路径转化为不超过logn级别数量的线段 预处理复杂度 O(n) ",
            "需要初始化为0的变量: idx,cnt,h[],hch[]",
            "预处理: dfs1(1,-1,1); dfs2(1,1);"
        ],
        "prefix": "#heavy-path-decomposition"
    },
    "[DS] Link Cut Tree": {
        "body": [
            "template<class Info,class Tag,int MAX_SIZE,",
            "         bool CHECK_LINK = 0,bool CHECK_CUT = 0,bool ASSERT = 0>",
            "struct LinkCutTree {",
            "    #define lch tr[u].ch[0]",
            "    #define rch tr[u].ch[1]",
            "    #define wch(u) (tr[tr[u].p].ch[1]==u)",
            "",
            "    struct Node {",
            "        int ch[2],p;",
            "        bool rev;",
            "        Info info;",
            "        Tag tag;",
            "        void update(const Tag &x) {",
            "            info.update(x);",
            "            tag.update(x);",
            "        }",
            "    };",
            "    array<Node, MAX_SIZE> tr;",
            "    array<int, MAX_SIZE> stk;",
            "",
            "    bool is_root(int u) {",
            "        return tr[tr[u].p].ch[0]!=u&&tr[tr[u].p].ch[1]!=u;",
            "    }",
            "",
            "    void pushup(int u) {",
            "        tr[u].info.pushup(tr[lch].info,tr[rch].info);",
            "    }",
            "",
            "    void pushrev(int u) {",
            "        tr[u].info.reverse();",
            "        swap(lch,rch);",
            "        tr[u].rev^=1;",
            "    }",
            "",
            "    void pushdn(int u) {",
            "        if(tr[u].rev) {",
            "            if(lch) pushrev(lch);",
            "            if(rch) pushrev(rch);",
            "            tr[u].rev=0;",
            "        }",
            "        if(lch) tr[lch].update(tr[u].tag);",
            "        if(rch) tr[rch].update(tr[u].tag);",
            "        tr[u].tag.clear();",
            "    }",
            "",
            "    void rotate(int x) {",
            "        int y=tr[x].p,z=tr[y].p,k=wch(x);",
            "        if(!is_root(y)) tr[z].ch[wch(y)]=x;",
            "        tr[y].ch[k]=tr[x].ch[!k],tr[tr[y].ch[k]].p=y;",
            "        tr[x].ch[!k]=y,tr[y].p=x,tr[x].p=z;",
            "        pushup(y),pushup(x);",
            "    }",
            "",
            "    void splay(int u) {",
            "        int top=0,fa=u;",
            "        stk[++top]=fa;",
            "        while(!is_root(fa)) stk[++top]=fa=tr[fa].p;",
            "        while(top) pushdn(stk[top--]);",
            "        for(;!is_root(u);rotate(u))",
            "            if(!is_root(fa=tr[u].p)) rotate(wch(u)==wch(fa)?fa:u);",
            "    }",
            "",
            "    int access(int u) {",
            "        int v=0;",
            "        for(;u;v=u,u=tr[u].p)",
            "            splay(u),rch=v,pushup(u);",
            "        return v;",
            "    }",
            "",
            "    void make_root(int u) {",
            "        access(u);",
            "        splay(u);",
            "        pushrev(u);",
            "    }",
            "",
            "    int split(int u,int v) {",
            "        make_root(u);",
            "        access(v);",
            "        splay(v);",
            "        return v;",
            "    }",
            "",
            "    int find_root(int u) {",
            "        access(u);",
            "        splay(u);",
            "        while(lch) pushdn(u),u=lch;",
            "        splay(u);",
            "        return u;",
            "    }",
            "",
            "    bool same(int u,int v) {",
            "        make_root(u);",
            "        return find_root(v)==u;",
            "    }",
            "",
            "    bool link(int u,int v) {",
            "        make_root(u);",
            "        if(CHECK_LINK&&find_root(v)==u)",
            "            return assert(!ASSERT),0;",
            "        tr[u].p=v;",
            "        return 1;",
            "    }",
            "",
            "    bool cut(int u,int v) {",
            "        make_root(u);",
            "        if(CHECK_CUT&&!(find_root(v)==u&&rch==v&&!tr[v].ch[0]))",
            "            return assert(!ASSERT),0;",
            "        else access(v),splay(u);",
            "        rch=tr[v].p=0;",
            "        pushup(u);",
            "        return 1;",
            "    }",
            "",
            "    int lca(int u,int v) {",
            "        access(u);",
            "        return access(v);",
            "    }",
            "",
            "    int lca(int rt,int u,int v) {",
            "        make_root(rt);",
            "        return lca(u,v);",
            "    }",
            "",
            "    void modify(int u,const Tag &x) {",
            "        if(!is_root(u)) splay(u);",
            "        tr[u].update(x);",
            "    }",
            "",
            "    Info &info(int u) {",
            "        return tr[u].info;",
            "    }",
            "",
            "    #undef lch",
            "    #undef rch",
            "    #undef wch",
            "};",
            "",
            "struct Tag {",
            "",
            "    void update(const Tag &x) {",
            "        ",
            "    }",
            "",
            "    void clear() {",
            "        ",
            "    }",
            "};",
            "",
            "struct Info {",
            "",
            "    //* lch+parent+rch",
            "    void pushup(const Info &l,const Info &r) {",
            "        ",
            "    }",
            "",
            "    void update(const Tag &x) {",
            "",
            "    }",
            "",
            "    void reverse() {}",
            "};",
            "",
            "LinkCutTree<Info,Tag,N> lct;"
        ],
        "description": "Link Cut Tree",
        "prefix": "#lct"
    },
    "[DS] Merge Split Segment Tree": {
        "body": [
            "struct MergeSplitSegmentTree {",
            "",
            "    #define lch tr[u].ch[0]",
            "    #define rch tr[u].ch[1]",
            "    constexpr static int MAX_SIZE=1e7+10;",
            "    ",
            "    struct Node {",
            "        int ch[2];",
            "        int cnt;",
            "    } tr[MAX_SIZE];",
            "    int idx;",
            "",
            "    int new_node() {",
            "        // assert(idx<MAX_SIZE);",
            "        return ++idx;",
            "    }",
            "",
            "    void pushup(int u) {",
            "        if(lch&&rch) ;",
            "        else if(lch) ;",
            "        else if(rch) ;",
            "    }",
            "",
            "    // remember to pushdn laze tag",
            "    void pushdn(int u) {",
            "        if(lch) ;",
            "        if(rch) ;",
            "",
            "    }",
            "    ",
            "    void merge(int &u,int v) {",
            "        if(!u&&!v) return;",
            "        if(!u||!v) u=u|v;",
            "        else {",
            "            pushdn(u);pushdn(v);",
            "            merge(lch,tr[v].ch[0]);",
            "            merge(rch,tr[v].ch[1]);",
            "            pushup(u);",
            "        }",
            "    }",
            "",
            "    // k][k+1",
            "    void split(int &u,int &v,int l,int r,int k) {",
            "        if(!u||k>=r) return;",
            "        if(k<l) swap(u,v);",
            "        else {",
            "            v=new_node();",
            "            int mid=l+r>>1;",
            "            if(k<=mid) swap(rch,tr[v].ch[1]);",
            "            pushdn(u);",
            "            if(k<mid) split(lch, tr[v].ch[0], l, mid, k);",
            "            else split(rch, tr[v].ch[1], mid+1, r, k);",
            "            pushup(u),pushup(v);",
            "        }",
            "    }",
            "",
            "    int kth(int u,int l,int r,int k) {",
            "        if(tr[u].cnt<k) return -1;",
            "        if(l==r) return l;",
            "        int mid=l+r>>1;",
            "        pushdn(u);",
            "        if(tr[lch].cnt>=k) return kth(lch, l, mid, k);",
            "        return kth(rch, mid+1, r, k-tr[lch].cnt);",
            "    }",
            "",
            "    void build(int &u,int l,int r,int p) {",
            "        u=new_node();",
            "        if(l==r) ;",
            "        else {",
            "            int mid=l+r>>1;",
            "            if(p<=mid) build(lch,l,mid,p);",
            "            else build(rch,mid+1,r,p);",
            "            pushup(u);",
            "        }",
            "    }",
            "",
            "    #undef lch",
            "    #undef rch",
            "",
            "} sgt;"
        ],
        "description": [
            "线段树合并&分裂",
            "[时间复杂度] 无论以何种顺序合并与分裂,时间复杂度为O((n+m)logn) (m为分裂次数)",
            "[空间复杂度] O((n+m)logn) 直接合并为(n+m)logn,不破坏子树结构为2(n+m)logn"
        ],
        "prefix": "#merge_split_segment_tree"
    },
    "[DS] Persistent 01-Trie": {
        "body": [
            "template<typename I> struct PersistentBinaryTrie {",
            "    constexpr static int H=sizeof(I)*8-1;",
            "    struct Node {",
            "        int ch[2];",
            "        int cnt;",
            "    };",
            "    vector<Node> tr;",
            "    vector<int> root;",
            "    ",
            "    int ver() { return root.size()-1; }",
            "",
            "    int new_root() {",
            "        root.push_back({});",
            "        return ver();",
            "    }",
            "",
            "    int new_node() {",
            "        tr.push_back({});",
            "        return tr.size()-1;",
            "    }",
            "",
            "    void insert(int &rt,int v,int val) {",
            "        int u=rt=new_node();",
            "        tr[u]=tr[v];",
            "        for(int i=H;i>=0;i--) {",
            "            bool x=val>>i&1;",
            "            u=tr[u].ch[x]=new_node();",
            "            v=tr[v].ch[x];",
            "            tr[u]=tr[v];",
            "            tr[u].cnt++;",
            "        }",
            "    }",
            "    int insert(int val) {",
            "        new_root();",
            "        insert(root[ver()],root[ver()-1],val);",
            "        return ver();",
            "    }",
            "",
            "    I xor_max(int u,int val) {",
            "        u=root[u];",
            "        I res{};",
            "        for(int i=H;i>=0;i--) {",
            "            bool x=val>>i&1^1;",
            "            if(tr[tr[u].ch[x]].cnt) {",
            "                res|=1<<i;",
            "                u=tr[u].ch[x];",
            "            }",
            "            else u=tr[u].ch[x^1];",
            "        }",
            "        return res;",
            "    }",
            "",
            "    I range_xor_max(int u,int v,int val) {",
            "        u=root[u],v=root[v];",
            "        I res{};",
            "        for(int i=H;i>=0;i--) {",
            "            bool x=val>>i&1^1;",
            "            if(tr[tr[u].ch[x]].cnt-tr[tr[v].ch[x]].cnt) {",
            "                res|=1<<i;",
            "                u=tr[u].ch[x];",
            "                v=tr[v].ch[x];",
            "            }",
            "            else u=tr[u].ch[x^1],v=tr[v].ch[x^1];",
            "        }",
            "        return res;",
            "    }",
            "",
            "    void clear() {",
            "        tr.clear();",
            "        new_root();",
            "        new_node();",
            "    }",
            "",
            "    explicit PersistentBinaryTrie(int size=0) {",
            "        tr.reserve(size*(H+1));",
            "        clear();",
            "    }",
            "};"
        ],
        "description": "Persistent 01-Trie",
        "prefix": "#persistent_01_tire"
    },
    "[DS] Persistent Segment Tree": {
        "body": [
            "template<class Info,int node_size>",
            "struct PersistentSegmentTree {",
            "    int idx,rng_l,rng_r;",
            "    vector<int> root;",
            "    array<Info, node_size> info;",
            "    array<int, node_size> lch,rch;",
            "",
            "    int ver() {",
            "        return root.size()-1;",
            "    }",
            "",
            "    int new_node() {",
            "        assert(idx<node_size);",
            "        return ++idx;",
            "    }",
            "",
            "    int new_root() {",
            "        root.emplace_back();",
            "        return ver();",
            "    }",
            "",
            "    void clone(int u,int v) {",
            "        info[u]=info[v];",
            "        lch[u]=lch[v];",
            "        rch[u]=rch[v];",
            "    }",
            "",
            "    void pushup(int u) {",
            "        info[u]=info[lch[u]]+info[rch[u]];",
            "    }",
            "",
            "    Info query(int u,int l,int r,int x,int y) {",
            "        if(l>y||r<x) return {};",
            "        if(l>=x&&r<=y) return info[u];",
            "        int mid=(l+r)/2;",
            "        return query(lch[u],l,mid,x,y)+query(rch[u],mid+1,r,x,y);",
            "    }",
            "    Info query(int u,int l,int r) {",
            "        return query(root[u],rng_l,rng_r,l,r);",
            "    }",
            "",
            "    Info range_query(int u,int v,int l,int r,int x,int y) {",
            "        if(l>y||r<x) return {};",
            "        if(l>=x&&r<=y) return info[u]-info[v];",
            "        int mid=(l+r)/2;",
            "        return range_query(lch[u],lch[v],l,mid,x,y)+",
            "               range_query(rch[u],rch[v],mid+1,r,x,y);",
            "    }",
            "    Info range_query(int u,int v,int l,int r) {",
            "        return range_query(root[u],root[v],rng_l,rng_r,l,r);",
            "    }",
            "",
            "    void modify(int &u,int v,int l,int r,int p,const Info &val) {",
            "        u=new_node();",
            "        clone(u, v);",
            "        if(l==r) info[u]+=val;",
            "        else {",
            "            int mid=(l+r)/2;",
            "            if(p<=mid) modify(lch[u],lch[v],l,mid,p,val);",
            "            else modify(rch[u],rch[v],mid+1,r,p,val);",
            "            pushup(u);",
            "        }",
            "    }",
            "    void modify(int u,int v,int p,const Info &val) {",
            "        modify(root[u],root[v],rng_l,rng_r,p,val);",
            "    }",
            "",
            "    int update(int p,const Info &val) {",
            "        new_root();",
            "        modify(root[ver()],root[ver()-1],rng_l,rng_r,p,val);",
            "        return ver();",
            "    }",
            "",
            "    template<class F>",
            "    int find_first(int u,int l,int r,int x,int y,F check) {",
            "        if(l>y||r<x||l>=x&&r<=y&&!check(info[u])) return -1;",
            "        if(l==r) return l;",
            "        int mid=(l+r)/2;",
            "        int res=find_first(lch[u],l,mid,x,y,check);",
            "        if(res==-1) res=find_first(rch[u],mid+1,r,x,y,check);",
            "        return res;",
            "    }",
            "    template<class F> int find_first(int u,int l,int r,F check) {",
            "        return find_first(root[u],rng_l,rng_r,l,r,check);",
            "    }",
            "",
            "    template<class F>",
            "    int find_last(int u,int l,int r,int x,int y,F check) {",
            "        if(l>y||r<x||l>=x&&r<=y&&!check(info[u])) return -1;",
            "        if(l==r) return l;",
            "        int mid=(l+r)/2;",
            "        int res=find_last(rch[u],mid+1,r,x,y,check);",
            "        if(res==-1) res=find_last(lch[u],l,mid,x,y,check);",
            "        return res;",
            "    }",
            "    template<class F> int find_last(int u,int l,int r,F check) {",
            "        return find_last(root[u],rng_l,rng_r,l,r,check);",
            "    }",
            "",
            "    void build(int &u,int l,int r) {",
            "        u=new_node();",
            "        info[u].init(l,r);",
            "        if(l!=r) {",
            "            int mid=(l+r)>>1;",
            "            build(lch[u],l,mid);",
            "            build(rch[u],mid+1,r);",
            "            pushup(u);",
            "        }",
            "    }",
            "    void build(int l,int r) {",
            "        build(root[new_root()],rng_l=l,rng_r=r);",
            "    }",
            "};",
            "",
            "struct Info {",
            "",
            "    void init(int l,int r) {",
            "        if(l!=r) return;",
            "",
            "    }",
            "    void init(int l) { init(l,l); }",
            "",
            "    friend Info operator+(const Info &l,const Info &r) {",
            "        Info res;",
            "        ",
            "        return res;",
            "    }",
            "    ",
            "    friend Info operator-(const Info &l,const Info &r) {",
            "        Info res;",
            "",
            "        return res;",
            "    }",
            "",
            "    Info &operator+=(const Info &v) {",
            "",
            "        return *this;",
            "    }",
            "};",
            "",
            "PersistentSegmentTree<Info, N*__lg(N)*4> sgt;"
        ],
        "description": "Persistent Segment Tree",
        "prefix": "#persistent_segment_tree"
    },
    "[DS] Potential Segment Tree": {
        "body": [
            "struct Info {",
            "    bool final;",
            "",
            "    void init(int l,int r) {",
            "        if(l!=r) return;",
            "",
            "    }",
            "    void init(int l) { init(l,l); }",
            "",
            "    friend Info operator+(const Info &l,const Info &r) {",
            "        Info res;",
            "",
            "        return res;",
            "    }",
            "",
            "    void operator--(int) {",
            "        ",
            "    }",
            "",
            "    explicit operator bool() const { return final; }",
            "};",
            "",
            "template<class Info,int size> struct SegmentTree {",
            "    #define lch (u<<1)",
            "    #define rch (u<<1|1)",
            "",
            "    struct Node {",
            "        int l,r;",
            "        Info info;",
            "        void init(int l,int r) {",
            "            this->l=l;",
            "            this->r=r;",
            "            info.init(l, r);",
            "        }",
            "    };",
            "",
            "    array<Node, 1<<__lg(size)<<2|1> tr;",
            "",
            "    void pushup(int u) {",
            "        tr[u].info=tr[lch].info+tr[rch].info;",
            "    }",
            "",
            "    Info query(int u,int l,int r) {",
            "        if(tr[u].l>=l&&tr[u].r<=r) { return tr[u].info; }",
            "        else {",
            "            int mid=(tr[u].l+tr[u].r)/2;",
            "            if(mid>=l&&mid<r) return query(lch,l,r)+query(rch,l,r);",
            "            else if(mid>=l) return query(lch,l,r);",
            "            return query(rch,l,r);",
            "        }",
            "    }",
            "    Info query(int l,int r) { return query(1,l,r); }",
            "",
            "    void release(int u,int l,int r) {",
            "        if(tr[u].info) return;",
            "        else if(tr[u].l==tr[u].r) tr[u].info--;",
            "        else {",
            "            int mid=(tr[u].l+tr[u].r)/2;",
            "            if(l<=mid) release(lch,l,r);",
            "            if(r>mid) release(rch,l,r);",
            "            pushup(u);",
            "        }",
            "    }",
            "    void release(int l,int r) { release(1,l,r); }",
            "",
            "    void build(int u,int l,int r) {",
            "        tr[u].init(l,r);",
            "        if(l!=r) {",
            "            int mid=(l+r)/2;",
            "            build(lch,l,mid);",
            "            build(rch,mid+1,r);",
            "            pushup(u);",
            "        }",
            "    }",
            "    void build(int l=1,int r=size) { build(1,l,r); }",
            "",
            "    #undef lch",
            "    #undef rch",
            "};",
            "SegmentTree<Info, N> sgt;"
        ],
        "description": "",
        "prefix": "potential_segment_tree"
    },
    "[DS] Segment Tree": {
        "body": [
            "template<class Info,class Tag,int size> struct SegmentTree {",
            "    #define lch ((u)<<1)",
            "    #define rch ((u)<<1|1)",
            "",
            "    int rng_l,rng_r;",
            "    constexpr static int node_size=1<<__lg(size)<<2|1;",
            "    array<Tag, node_size> tag;",
            "    array<Info, node_size> info;",
            "    array<bool, node_size> clean;",
            "",
            "    void pushup(int u) {",
            "        info[u]=info[lch]+info[rch];",
            "    }",
            "",
            "    void update(int u, const Tag &t) {",
            "        info[u]+=t;",
            "        tag[u]+=t;",
            "        clean[u]=0;",
            "    }",
            "",
            "    void pushdn(int u) {",
            "        if(clean[u]) return;",
            "        update(lch, tag[u]);",
            "        update(rch, tag[u]);",
            "        clean[u]=1;",
            "        tag[u].clear();",
            "    }",
            "",
            "    Info query(int u,int l,int r,int x,int y) {",
            "        if(l>y||r<x) return {};",
            "        if(l>=x&&r<=y) return info[u];",
            "        pushdn(u);",
            "        int mid=(l+r)/2;",
            "        return query(lch,l,mid,x,y)+query(rch,mid+1,r,x,y);",
            "    }",
            "    Info query(int l,int r) { return query(1,rng_l,rng_r,l,r); }",
            "",
            "    void modify(int u,int l,int r,int x,int y,const Tag &t) {",
            "        if(l>y||r<x) return;",
            "        if(l>=x&&r<=y) update(u, t);",
            "        else {",
            "            pushdn(u);",
            "            int mid=(l+r)/2;",
            "            if(mid>=x) modify(lch,l,mid,x,y,t);",
            "            if(mid<y) modify(rch,mid+1,r,x,y,t);",
            "            pushup(u);",
            "        }",
            "    }",
            "    void modify(int l,int r,const Tag &t) { modify(1,rng_l,rng_r,l,r,t); }",
            "",
            "    template<class F>",
            "    int find_first(int u,int l,int r,int x,int y,F check) {",
            "        if(l>y||r<x||l>=x&&r<=y&&!check(info[u])) return -1;",
            "        if(l==r) return l;",
            "        pushdn(u);",
            "        int mid=(l+r)/2;",
            "        int res=find_first(lch,l,mid,x,y,check);",
            "        if(res==-1) res=find_first(rch,mid+1,r,x,y,check);",
            "        return res;",
            "    }",
            "    template<class F> int find_first(int l,int r,F check) {",
            "        return find_first(1,rng_l,rng_r,l,r,check);",
            "    }",
            "",
            "    template<class F>",
            "    int find_last(int u,int l,int r,int x,int y,F check) {",
            "        if(l>y||r<x||l>=x&&r<=y&&!check(info[u])) return -1;",
            "        if(l==r) return l;",
            "        pushdn(u);",
            "        int mid=(l+r)/2;",
            "        int res=find_last(rch,mid+1,r,x,y,check);",
            "        if(res==-1) res=find_last(lch,l,mid,x,y,check);",
            "        return res;",
            "    }",
            "    template<class F> int find_last(int l,int r,F check) {",
            "        return find_last(1,rng_l,rng_r,l,r,check);",
            "    }",
            "",
            "    void build(int u,int l,int r) {",
            "        clean[u]=1;",
            "        info[u].init(l,r);",
            "        tag[u].clear();",
            "        if(l!=r) {",
            "            int mid=(l+r)/2;",
            "            build(lch,l,mid);",
            "            build(rch,mid+1,r);",
            "            pushup(u);",
            "        }",
            "    }",
            "    void build(int l=1,int r=size) { build(1,rng_l=l,rng_r=r); }",
            "",
            "    #undef lch",
            "    #undef rch",
            "};",
            "",
            "struct Tag {",
            "",
            "    void clear() {",
            "",
            "    }",
            "",
            "    Tag &operator+=(const Tag &t) {",
            "",
            "        return *this;",
            "    }",
            "};",
            "",
            "struct Info {",
            "",
            "    void init(int l,int r) {",
            "        if(l!=r) return;",
            "",
            "    }",
            "    void init(int l) { init(l,l); }",
            "",
            "    friend Info operator+(const Info &l,const Info &r) {",
            "        Info res;",
            "",
            "        return res;",
            "    }",
            "",
            "    Info &operator+=(const Tag &t) {",
            "",
            "        return *this;",
            "    }",
            "};",
            "",
            "SegmentTree<Info, Tag, N> sgt;"
        ],
        "description": "线段树",
        "prefix": "#segment_tree"
    },
    "[DS] Segment Tree (without lazy tag)": {
        "body": [
            "template<class Info,int size> struct SegmentTree {",
            "    #define lch ((u)<<1)",
            "    #define rch ((u)<<1|1)",
            "",
            "    int rng_l,rng_r;",
            "    constexpr static int node_size=1<<__lg(size)<<2|1;",
            "    array<Info, node_size> info;",
            "    array<int, size+1> leaf;",
            "",
            "    void pushup(int u) {",
            "        info[u]=info[lch]+info[rch];",
            "    }",
            "",
            "    Info query(int u,int l,int r,int x,int y) {",
            "        if(l>y||r<x) return {};",
            "        if(l>=x&&r<=y) return info[u];",
            "        int mid=(l+r)/2;",
            "        return query(lch,l,mid,x,y)+query(rch,mid+1,r,x,y);",
            "    }",
            "    Info query(int l,int r) { return query(1,rng_l,rng_r,l,r); }",
            "",
            "    void modify(int p,const Info &v) {",
            "        int u=leaf[p];",
            "        info[u]+=v;",
            "        while(u>>=1) pushup(u);",
            "    }",
            "",
            "    template<class F>",
            "    int find_first(int u,int l,int r,int x,int y,F check) {",
            "        if(l>y||r<x||l>=x&&r<=y&&!check(info[u])) return -1;",
            "        if(l==r) return l;",
            "        int mid=(l+r)/2;",
            "        int res=find_first(lch,l,mid,x,y,check);",
            "        if(res==-1) res=find_first(rch,mid+1,r,x,y,check);",
            "        return res;",
            "    }",
            "    template<class F> int find_first(int l,int r,F check) {",
            "        return find_first(1,rng_l,rng_r,l,r,check);",
            "    }",
            "",
            "    template<class F>",
            "    int find_last(int u,int l,int r,int x,int y,F check) {",
            "        if(l>y||r<x||l>=x&&r<=y&&!check(info[u])) return -1;",
            "        if(l==r) return l;",
            "        int mid=(l+r)/2;",
            "        int res=find_last(rch,mid+1,r,x,y,check);",
            "        if(res==-1) res=find_last(lch,l,mid,x,y,check);",
            "        return res;",
            "    }",
            "    template<class F> int find_last(int l,int r,F check) {",
            "        return find_last(1,rng_l,rng_r,l,r,check);",
            "    }",
            "",
            "    void build(int u,int l,int r) {",
            "        info[u].init(l,r);",
            "        if(l!=r) {",
            "            int mid=(l+r)/2;",
            "            build(lch,l,mid);",
            "            build(rch,mid+1,r);",
            "            pushup(u);",
            "        }",
            "        else leaf[l]=u;",
            "    }",
            "    void build(int l=1,int r=size) { build(1,rng_l=l,rng_r=r); }",
            "",
            "    #undef lch",
            "    #undef rch",
            "};",
            "",
            "struct Info {",
            "",
            "    void init(int l,int r) {",
            "        if(l!=r) return;",
            "",
            "    }",
            "    void init(int l) { init(l,l); }",
            "",
            "    friend Info operator+(const Info &l,const Info &r) {",
            "        Info res;",
            "",
            "        return res;",
            "    }",
            "",
            "    Info &operator+=(const Info &v) {",
            "        ",
            "        return *this;",
            "    }",
            "};",
            "",
            "SegmentTree<Info, N> sgt;"
        ],
        "description": "单点修改线段树",
        "prefix": "#segment_tree_without_lazy_tag"
    },
    "[DS] Sparse Table": {
        "body": [
            "template<int size,typename T=int> struct SparseTable {",
            "    constexpr static int M=__lg(size);",
            "    T arr[size],st[M][size];",
            "",
            "    void build(int n) {",
            "        for(int i=1;i<=n;i++) st[0][i]=arr[i];",
            "        for(int k=1,t=1<<k;k<M;k++,t<<=1)",
            "            for(int i=1,j=i+t-1,mid=i+t/2;j<=n;i++,j++,mid++)",
            "                st[k][i]=max(st[k-1][i],st[k-1][mid]);",
            "    }",
            "",
            "    T query(int l,int r) {",
            "        if(r<l) return 0;",
            "        int k=__lg(r-l+1);",
            "        return max(st[k][l],st[k][r-(1<<k)+1]);",
            "    }",
            "};"
        ],
        "description": "Sparse Table",
        "prefix": "#st"
    },
    "[DS] Treap": {
        "body": [
            "constexpr int N=1e5+10,INF=0x3f3f3f3f;",
            "",
            "struct NODE{",
            "    int l,r;",
            "    int key,val;",
            "    int cnt,size;",
            "}tr[N];",
            "int root,idx;",
            "",
            "int new_node(int key){",
            "    tr[++idx].key=key;",
            "    tr[idx].val=rand();",
            "    tr[idx].cnt=tr[idx].size=1;",
            "    return idx;",
            "}",
            "",
            "void pushup(int id){",
            "    tr[id].size=tr[tr[id].l].size+tr[tr[id].r].size+tr[id].cnt;",
            "}",
            "",
            "void zag(int &p){",
            "    int q=tr[p].r;",
            "    tr[p].r=tr[q].l,tr[q].l=p;",
            "    pushup(p),pushup(q);",
            "    p=q;",
            "}",
            "",
            "void zig(int &p){",
            "    int q=tr[p].l;",
            "    tr[p].l=tr[q].r,tr[q].r=p;",
            "    pushup(p),pushup(q);",
            "    p=q;",
            "}",
            "",
            "void insert(int &p,int key){",
            "    if(!p) p=new_node(key);",
            "    else if(tr[p].key==key) tr[p].cnt++;",
            "    else if(key<tr[p].key) {",
            "        insert(tr[p].l,key);",
            "        if(tr[tr[p].l].val>tr[p].val) zig(p);",
            "    }",
            "    else {",
            "        insert(tr[p].r,key);",
            "        if(tr[tr[p].r].val>tr[p].val) zag(p);",
            "    }",
            "    pushup(p);",
            "}",
            "",
            "void erase(int &p,int key){",
            "    if(!p) return;",
            "    if(tr[p].key==key){",
            "        if(tr[p].cnt>1) tr[p].cnt--;",
            "        else if(!tr[p].l&&!tr[p].r) p=0;",
            "        else if(!tr[p].l||tr[tr[p].r].val>tr[tr[p].l].val)",
            "            zag(p),erase(tr[p].l,key);",
            "        else zig(p),erase(tr[p].r,key);",
            "    }",
            "    else if(key<tr[p].key) erase(tr[p].l,key);",
            "    else erase(tr[p].r,key);",
            "    pushup(p);",
            "}",
            "",
            "int get_rank(int p,int key){",
            "    if(!p) return INF;",
            "    if(tr[p].key==key) return tr[tr[p].l].size+1;",
            "    else if(key<tr[p].key) return get_rank(tr[p].l,key);",
            "    return tr[tr[p].l].size+tr[p].cnt+get_rank(tr[p].r,key);",
            "}",
            "",
            "int get_key(int p,int rank){",
            "    if(!p) return INF;",
            "    int lrank=tr[tr[p].l].size;",
            "    if(rank<=lrank) return get_key(tr[p].l,rank);",
            "    else if(rank<=lrank+tr[p].cnt) return tr[p].key;",
            "    return get_key(tr[p].r,rank-lrank-tr[p].cnt);",
            "}",
            "",
            "int get_prev(int p,int key){",
            "    if(!p) return -INF;",
            "    if(tr[p].key>=key) return get_prev(tr[p].l,key);",
            "    return max(tr[p].key,get_prev(tr[p].r,key));",
            "}",
            "",
            "int get_next(int p,int key){",
            "    if(!p) return INF;",
            "    if(tr[p].key<=key) return get_next(tr[p].r,key);",
            "    return min(tr[p].key,get_next(tr[p].l,key));",
            "}",
            "",
            "void build(){",
            "    root=new_node(-INF);",
            "    tr[root].r=new_node(INF);",
            "    pushup(root);",
            "    if(tr[1].val<tr[2].val) zag(root);",
            "}"
        ],
        "description": "Treap",
        "prefix": "#treap"
    },
    "[DS] Trie": {
        "body": [
            "struct Trie {",
            "    constexpr static int A=26,B='a';",
            "    struct Node {",
            "        int ch[A];",
            "        int cnt;",
            "    };",
            "    vector<Node> tr;",
            "",
            "    int new_node() { tr.push_back({}); return tr.size()-1; }",
            "",
            "    int extend(int u,int x) {",
            "        if(!tr[u].ch[x-B]) tr[u].ch[x-B]=new_node();",
            "        tr[tr[u].ch[x-B]].cnt++;",
            "        return tr[u].ch[x-B];",
            "    }",
            "",
            "    template<typename T> void insert(const T &s) {",
            "        int u=0;",
            "        for(auto x:s) u=extend(u, x);",
            "    }",
            "",
            "    void clear() { tr.clear(); new_node(); }",
            "    Trie() { clear(); }",
            "    Trie(int size) { tr.reserve(size); clear(); }",
            "} trie;"
        ],
        "description": "Trie",
        "prefix": "#trie"
    },
    "[DS] Undoable Disjoint Union Set": {
        "body": [
            "struct DisjointUnionSet {",
            "    vector<int> fa,sz;",
            "    vector<pair<int&,int>> fah,szh;",
            "",
            "    void init(int n) {",
            "        fah.clear();",
            "        szh.clear();",
            "        fa.resize(n+1);",
            "        sz.assign(n+1,1);",
            "        iota(fa.begin(), fa.end(), 0);",
            "    }",
            "",
            "    int find(int x) {",
            "        while(x!=fa[x]) x=fa[x];",
            "        return x;",
            "    }",
            "",
            "    bool same(int x,int y) {",
            "        return find(x)==find(y);",
            "    }",
            "",
            "    bool join(int x,int y) {",
            "        x=find(x);",
            "        y=find(y);",
            "        if(x==y) {",
            "            fah.emplace_back(fa[0],fa[0]);",
            "            szh.emplace_back(sz[0],sz[0]);",
            "            return false;",
            "        }",
            "        if(sz[x]<sz[y]) swap(x,y);",
            "        fah.emplace_back(fa[y],fa[y]);",
            "        szh.emplace_back(sz[x],sz[x]);",
            "        sz[x]+=sz[y];",
            "        fa[y]=x;",
            "        return true;",
            "    }",
            "",
            "    void undo() {",
            "        assert(!fah.empty());",
            "        fah.back().first=fah.back().second;",
            "        szh.back().first=szh.back().second;",
            "        fah.pop_back(),szh.pop_back();",
            "    }",
            "",
            "    int size(int x) {",
            "        return sz[find(x)];",
            "    }",
            "",
            "    DisjointUnionSet() = default;",
            "    DisjointUnionSet(int n) { init(n); }",
            "} dsu;"
        ],
        "description": "",
        "prefix": "#dsu_undo"
    },
    "[DS] virtual tree": {
        "body": [
            "namespace vt {",
            "    constexpr int N=${1:1e5+10},M=__lg(N); // ***",
            "    vector<int> vt[N],adj[N];",
            "    int stk[N],top,id[N],idx;",
            "    int fa[N][M+1],dep[N];",
            "    bool key[N];",
            "    ",
            "    void lca_init(int u,int p) {",
            "        dep[u]=dep[p]+1;",
            "        for(int v:adj[u]) {",
            "            if(v==p) continue;",
            "            fa[v][0]=u;",
            "            for(int i=1;i<=M;i++)",
            "                fa[v][i]=fa[fa[v][i-1]][i-1];",
            "            lca_init(v,u);",
            "        }",
            "    }",
            "    ",
            "    int lca(int u,int v) {",
            "        if(dep[u]<dep[v]) swap(u,v);",
            "        for(int k=M;~k;k--)",
            "            if(dep[fa[u][k]]>=dep[v])",
            "                u=fa[u][k];",
            "        if(u==v) return u;",
            "        for(int k=M;~k;k--)",
            "            if(fa[u][k]!=fa[v][k])",
            "                u=fa[u][k],v=fa[v][k];",
            "        return fa[u][0];",
            "    }",
            "",
            "    void relabel(int u,int fa) {",
            "        id[u]=++idx;",
            "        for(int v:adj[u]) if(v!=fa) relabel(v, u);",
            "    }",
            "",
            "    void build(vector<int> &vec) {",
            "        sort(vec.begin(),vec.end(),[](int x,int y) {",
            "            return id[x]<id[y];",
            "        });",
            "",
            "        // TODO clearup dirt memory",
            "        auto clear=[&](int u) {",
            "            vt[u].clear();",
            "            key[u]=0;",
            "        };",
            "",
            "        auto add=[&](int u,int v) {",
            "            vt[u].emplace_back(v);",
            "        };",
            "        ",
            "        clear(1);",
            "        stk[top=0]=1;",
            "        for(int u:vec) {",
            "            if(u==1) continue;",
            "            int p=lca(u,stk[top]);",
            "            if(p!=stk[top]) {",
            "                while(id[p]<id[stk[top-1]])",
            "                    add(stk[top-1],stk[top]),top--;",
            "                if(id[p]!=id[stk[top-1]])",
            "                    clear(p),add(p,stk[top]),stk[top]=p;",
            "                else add(p,stk[top--]);",
            "            }",
            "            clear(u);",
            "            stk[++top]=u;",
            "            key[u]=1;",
            "        }",
            "        for(int i=0;i<top;i++) add(stk[i],stk[i+1]);",
            "    }",
            "",
            "    void init() {",
            "        lca_init(1, 0);",
            "        relabel(1, 0);",
            "    }",
            "",
            "    void clear(int n) {",
            "        idx=0;",
            "        for(int i=0;i<=n;i++) adj[i].clear();",
            "    }",
            "}"
        ],
        "description": [
            "虚树\n",
            "能在O(klogn)时间内提取树上的k个关键点建成一棵新树,并且新树的点数不超过2k"
        ],
        "prefix": "#virtual_tree"
    },
    "[General] Data Generator": {
        "body": [
            "#include <algorithm>",
            "#include <cstdint>",
            "#include <fstream>",
            "#include <iostream>",
            "#include <testlib.h>",
            "using namespace std;",
            "",
            "#define endl '\\n'",
            "using LL=long long;",
            "constexpr int files=1;",
            "",
            "void solve() {",
            "    for(int z=1;z<=files;z++) {",
            "        fstream fout(\"data/\"+to_string(z)+\".in\",ios::out);",
            "        $0",
            "    }",
            "}",
            "",
            "int main(int argc, char *argv[]) {",
            "    ios::sync_with_stdio(0);",
            "    cin.tie(nullptr);",
            "    registerGen(argc, argv, 1);",
            "    solve();",
            "    return 0;",
            "}"
        ],
        "description": "Data Generator",
        "prefix": "#datagen"
    },
    "[General] Debug": {
        "body": [
            "// #define ONLINE_JUDGE",
            "#ifndef ONLINE_JUDGE",
            "#include <heltim7/debug>",
            "#else",
            "#define debug(...) 7",
            "#endif"
        ],
        "description": "C++ fast debuger",
        "prefix": "#debug"
    },
    "[General] Fast IO": {
        "body": [
            "namespace fast_io {",
            "    constexpr int MAXBUF = 1 << 20, MAXLEN = 1 << 20;",
            "    char buf[MAXBUF], *pl, *pr;",
            "    char str[MAXLEN];",
            "",
            "    #define gc() \\",
            "    (pl == pr && (pr = (pl = buf) + fread(buf, 1, MAXBUF, stdin), pl == pr) \\",
            "    ? EOF : *pl++)",
            "",
            "    template<typename T> T rd(T &x) {",
            "        x = 0;",
            "        T f = 1;",
            "        char c = gc();",
            "        while (!isdigit(c)) {",
            "            if (c == '-') f = -1;",
            "            c = gc();",
            "        }",
            "        while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc();",
            "        if (c != '.') return x = x * f;",
            "        for (double t = 0.1; c = gc(), isdigit(c); t *= 0.1) x += (c - '0') * t;",
            "        return x = x * f;",
            "    }",
            "",
            "    char* rd(char *p = str) {",
            "        char c = gc(), *h = p;",
            "        while (!isgraph(c)) c = gc();",
            "        while (isgraph(c)) *p++ = c, c = gc();",
            "        *p = '\\0';",
            "        return h;",
            "    }",
            "",
            "    char rd(char &c) {",
            "        c = gc();",
            "        while (!isgraph(c)) c = gc();",
            "        return c;",
            "    }",
            "",
            "    string rd(string &s) { return s = rd(str); }",
            "",
            "    template<typename... T> auto read(T&... x) { return (rd(x),...); }",
            "    #undef gc",
            "",
            "    constexpr int MAXPBUF = 1 << 20, PRECISION = 7;",
            "    char pbuf[MAXPBUF], *pp = pbuf;",
            "",
            "    void clear_buffer() { fwrite(pbuf, 1, pp-pbuf, stdout), pp = pbuf; }",
            "",
            "    void push(const char &c) {",
            "        if (pp - pbuf == MAXPBUF) clear_buffer();",
            "        *pp++ = c;",
            "    }",
            "",
            "    template<typename T> void wt(T x) {",
            "        if (x < 0) push('-'), x = -x;",
            "        static int sta[40];",
            "        int top = 0;",
            "        do {",
            "            sta[top++] = x % 10;",
            "        } while (x/=10);",
            "        while (top) push(sta[--top] + '0');",
            "    }",
            "",
            "    template<typename T> void wt_f(T x,int p) {",
            "        if (x < 0) push('-'), x = -x;",
            "        long long pre = (long long)x;",
            "        wt(pre);",
            "        x -= pre;",
            "        if (p) push('.');",
            "        while (p--) {",
            "            x *= 10;",
            "            int t = (int)x;",
            "            x -= t;",
            "            push(t + '0');",
            "        }",
            "    }",
            "",
            "    void wt(const char &c) { push(c); }",
            "    void wt(const string &s) { for (auto &x:s) push(x); }",
            "    void wt(const char *p) { while (*p != '\\0') push(*p++); }",
            "",
            "    void wt(const float &x, int p = PRECISION) { wt_f(x,p); }",
            "    void wt(const double &x, int p = PRECISION) { wt_f(x,p); }",
            "    void wt(const long double &x, int p = PRECISION) { wt_f(x,p); }",
            "",
            "    template<typename... T> void write(const T&... x) { (wt(x),...); }",
            "    template<typename T> void writef(const T &x,const int &p) { wt_f(x,p); }",
            "",
            "    struct IO {",
            "        template<typename T> friend IO& ",
            "        operator>>(IO &io, T& x) { rd(x); return io; }",
            "",
            "        template<typename T> friend IO&",
            "        operator<<(IO &io, const T& x) { wt(x); return io; }",
            "",
            "        ~IO() { clear_buffer(); }",
            "    } static io;",
            "",
            "} using fast_io::read,fast_io::write,fast_io::writef,fast_io::io;"
        ],
        "description": [
            "fast input/output based on fread/fwrite",
            "",
            "基于fread和fwrite的快读快写",
            "",
            "## Usage:",
            "1. read(x);                 读入一个变量",
            "2. write(x);                输出一个变量",
            "3. write(x,y);              输出精度为y的浮点数x,精度默认值为PRECISION",
            "4. reads(...); writes(...); 多参数读写,不支持精度控制且无返回值",
            "5. io::clear_buffer();      手动清空输出缓冲",
            "",
            "## Features:",
            "1. 支持 int,long long,int128,float,double,long double,char(array),string",
            "2. 退出程序会自动清空输出缓冲",
            "",
            "## Parameters:",
            "1. MAXBUF/MAXPBUF 读入/输出缓存大小,数值越大越占内存,fread/fwrite执行的操作越少",
            "                  BUF的大小不影响功能,通常保持不变即可,预设大小的缓存数组会占用3-4M内存",
            "2. MAXLEN         单个字符串长度,字符串的最大连续长度,如果超出则会发生数组越界",
            "3. PRECISION      默认精度",
            "",
            "## Note:",
            "1. 不需要using namespace io,已经define了read和write",
            "2. 不要关闭同步流(std::ios::sync_with_stdio(true);)",
            "3. 如果使用了read,那么不能再使用其他输入函数例如scanf和cin,会导致io顺序错误",
            "   write同理,这是由快读快写的缓冲机制决定的,除非事先清空缓冲",
            "4. 浮点数输出不会执行四舍五入,并且可能输出-0"
        ],
        "prefix": "#fast_io"
    },
    "[General] Fast Input": {
        "body": [
            "namespace fast_io {",
            "    constexpr int MAXBUF = 1e6;",
            "    char buf[MAXBUF], *pl, *pr;",
            "",
            "    #define gc() \\",
            "    (pl == pr && (pr = (pl = buf) + fread(buf, 1, MAXBUF, stdin), pl == pr) \\",
            "    ? EOF : *pl++)",
            "",
            "    template<typename T> T rd(T &x) {",
            "        x = 0;",
            "        T f = 1;",
            "        char c = gc();",
            "        while (!isdigit(c)) {",
            "            if (c == '-') f = -1;",
            "            c = gc();",
            "        }",
            "        while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc();",
            "        return x = x * f;",
            "    }",
            "",
            "    template<typename... T> auto read(T&... x) { return (rd(x),...); }   ",
            "    #undef gc",
            "",
            "    struct IO {",
            "        template<typename T> friend IO&",
            "        operator>>(IO &io, T& x) { rd(x); return io; }",
            "    } static io;",
            "}",
            "using fast_io::read,fast_io::io;"
        ],
        "description": "fast input based on fread",
        "prefix": "#fast_input"
    },
    "[General] New File": {
        "body": [
            "#include <algorithm>",
            "#include <array>",
            "#include <cassert>",
            "#include <cstring>",
            "#include <iostream>",
            "#include <map>",
            "#include <numeric>",
            "#include <queue>",
            "#include <set>",
            "#include <tuple>",
            "#include <vector>",
            "using namespace std;",
            "",
            "#define endl '\\n'",
            "using LL=long long;",
            "",
            "void solve() {",
            "    $0",
            "}",
            "",
            "int main() {",
            "    ios::sync_with_stdio(0);",
            "    cin.tie(nullptr);",
            "    solve();",
            "    return 0;",
            "}"
        ],
        "description": "C++ 头文件和默认参数",
        "prefix": "#new"
    },
    "[General] New File Multi-testcase": {
        "body": [
            "#include <algorithm>",
            "#include <array>",
            "#include <cassert>",
            "#include <cstring>",
            "#include <iostream>",
            "#include <map>",
            "#include <numeric>",
            "#include <queue>",
            "#include <set>",
            "#include <tuple>",
            "#include <vector>",
            "using namespace std;",
            "",
            "#define endl '\\n'",
            "using LL=long long;",
            "",
            "void solve() {",
            "    $0",
            "}",
            "",
            "int main() {",
            "    ios::sync_with_stdio(0);",
            "    cin.tie(nullptr);",
            "    int t;",
            "    cin>>t;",
            "    while(t--) solve();",
            "    return 0;",
            "}"
        ],
        "description": "C++ 头文件和默认参数,多组数据",
        "prefix": "#newt"
    },
    "[General] Prime Table 1e18": {
        "body": [
            // "{1000000000000000003,1000000000000000009,1000000000000000031,1000000000000000079,1000000000000000177,1000000000000000183,1000000000000000201,1000000000000000283,1000000000000000381,1000000000000000387,1000000000000000507,1000000000000000523,1000000000000000583,1000000000000000603,1000000000000000619,1000000000000000621,1000000000000000799,1000000000000000841,1000000000000000861,1000000000000000877,1000000000000000913,1000000000000000931,1000000000000000997,1000000000000001093,1000000000000001191,1000000000000001267,1000000000000001323,1000000000000001347,1000000000000001359,1000000000000001453,1000000000000001459,1000000000000001537,1000000000000001563,1000000000000001593,1000000000000001659,1000000000000001683,1000000000000001729,1000000000000001743,1000000000000001771,1000000000000001827,1000000000000001879,1000000000000001953,1000000000000002049,1000000000000002097,1000000000000002137,1000000000000002217,1000000000000002271,1000000000000002319,1000000000000002481,1000000000000002493};",
            "{0xde0b6b3a7640003,0xde0b6b3a7640009,0xde0b6b3a764001f,0xde0b6b3a764004f,0xde0b6b3a76400b1,0xde0b6b3a76400b7,0xde0b6b3a76400c9,0xde0b6b3a764011b,0xde0b6b3a764017d,0xde0b6b3a7640183,0xde0b6b3a76401fb,0xde0b6b3a764020b,0xde0b6b3a7640247,0xde0b6b3a764025b,0xde0b6b3a764026b,0xde0b6b3a764026d,0xde0b6b3a764031f,0xde0b6b3a7640349,0xde0b6b3a764035d,0xde0b6b3a764036d,0xde0b6b3a7640391,0xde0b6b3a76403a3,0xde0b6b3a76403e5,0xde0b6b3a7640445,0xde0b6b3a76404a7,0xde0b6b3a76404f3,0xde0b6b3a764052b,0xde0b6b3a7640543,0xde0b6b3a764054f,0xde0b6b3a76405ad,0xde0b6b3a76405b3,0xde0b6b3a7640601,0xde0b6b3a764061b,0xde0b6b3a7640639,0xde0b6b3a764067b,0xde0b6b3a7640693,0xde0b6b3a76406c1,0xde0b6b3a76406cf,0xde0b6b3a76406eb,0xde0b6b3a7640723,0xde0b6b3a7640757,0xde0b6b3a76407a1,0xde0b6b3a7640801,0xde0b6b3a7640831,0xde0b6b3a7640859,0xde0b6b3a76408a9,0xde0b6b3a76408df,0xde0b6b3a764090f,0xde0b6b3a76409b1,0xde0b6b3a76409bd};"
        ],
        "description": "big primes (1e18)",
        "prefix": "#prime_table_1e18"
    },
    "[General] Prime Table 1e9": {
        "body": [
            // "{1000000007,1000000009,1000000021,1000000033,1000000087,1000000093,1000000097,1000000103,1000000123,1000000181,1000000207,1000000223,1000000241,1000000271,1000000289,1000000297,1000000321,1000000349,1000000363,1000000403,1000000409,1000000411,1000000427,1000000433,1000000439,1000000447,1000000453,1000000459,1000000483,1000000513,1000000531,1000000579,1000000607,1000000613,1000000637,1000000663,1000000711,1000000753,1000000787,1000000801,1000000829,1000000861,1000000871,1000000891,1000000901,1000000919,1000000931,1000000933,1000000993,1000001011};",
            "{0x3b9aca07,0x3b9aca09,0x3b9aca15,0x3b9aca21,0x3b9aca57,0x3b9aca5d,0x3b9aca61,0x3b9aca67,0x3b9aca7b,0x3b9acab5,0x3b9acacf,0x3b9acadf,0x3b9acaf1,0x3b9acb0f,0x3b9acb21,0x3b9acb29,0x3b9acb41,0x3b9acb5d,0x3b9acb6b,0x3b9acb93,0x3b9acb99,0x3b9acb9b,0x3b9acbab,0x3b9acbb1,0x3b9acbb7,0x3b9acbbf,0x3b9acbc5,0x3b9acbcb,0x3b9acbe3,0x3b9acc01,0x3b9acc13,0x3b9acc43,0x3b9acc5f,0x3b9acc65,0x3b9acc7d,0x3b9acc97,0x3b9accc7,0x3b9accf1,0x3b9acd13,0x3b9acd21,0x3b9acd3d,0x3b9acd5d,0x3b9acd67,0x3b9acd7b,0x3b9acd85,0x3b9acd97,0x3b9acda3,0x3b9acda5,0x3b9acde1,0x3b9acdf3};"
        ],
        "description": "big primes (1e9)",
        "prefix": "#prime_table_1e9"
    },
    "[General] Random Prime 1e18": {
        "body": [
            "mt19937 gen=mt19937(random_device{}());",
            "vector<LL> num{0xde0b6b3a7640003,0xde0b6b3a7640009,0xde0b6b3a764001f,0xde0b6b3a764004f,0xde0b6b3a76400b1,0xde0b6b3a76400b7,0xde0b6b3a76400c9,0xde0b6b3a764011b,0xde0b6b3a764017d,0xde0b6b3a7640183,0xde0b6b3a76401fb,0xde0b6b3a764020b,0xde0b6b3a7640247,0xde0b6b3a764025b,0xde0b6b3a764026b,0xde0b6b3a764026d,0xde0b6b3a764031f,0xde0b6b3a7640349,0xde0b6b3a764035d,0xde0b6b3a764036d,0xde0b6b3a7640391,0xde0b6b3a76403a3,0xde0b6b3a76403e5,0xde0b6b3a7640445,0xde0b6b3a76404a7,0xde0b6b3a76404f3,0xde0b6b3a764052b,0xde0b6b3a7640543,0xde0b6b3a764054f,0xde0b6b3a76405ad,0xde0b6b3a76405b3,0xde0b6b3a7640601,0xde0b6b3a764061b,0xde0b6b3a7640639,0xde0b6b3a764067b,0xde0b6b3a7640693,0xde0b6b3a76406c1,0xde0b6b3a76406cf,0xde0b6b3a76406eb,0xde0b6b3a7640723,0xde0b6b3a7640757,0xde0b6b3a76407a1,0xde0b6b3a7640801,0xde0b6b3a7640831,0xde0b6b3a7640859,0xde0b6b3a76408a9,0xde0b6b3a76408df,0xde0b6b3a764090f,0xde0b6b3a76409b1,0xde0b6b3a76409bd};",
            "LL random_prime() {",
            "    shuffle(num.begin(), num.end(), gen);",
            "    LL res=num.back();",
            "    num.pop_back();",
            "    return res;",
            "}"
        ],
        "description": "",
        "prefix": "#random_prime_1e18"
    },
    "[General] Random Prime 1e9": {
        "body": [
            "mt19937 gen=mt19937(random_device{}());",
            "vector<int> num{0x3b9aca07,0x3b9aca09,0x3b9aca15,0x3b9aca21,0x3b9aca57,0x3b9aca5d,0x3b9aca61,0x3b9aca67,0x3b9aca7b,0x3b9acab5,0x3b9acacf,0x3b9acadf,0x3b9acaf1,0x3b9acb0f,0x3b9acb21,0x3b9acb29,0x3b9acb41,0x3b9acb5d,0x3b9acb6b,0x3b9acb93,0x3b9acb99,0x3b9acb9b,0x3b9acbab,0x3b9acbb1,0x3b9acbb7,0x3b9acbbf,0x3b9acbc5,0x3b9acbcb,0x3b9acbe3,0x3b9acc01,0x3b9acc13,0x3b9acc43,0x3b9acc5f,0x3b9acc65,0x3b9acc7d,0x3b9acc97,0x3b9accc7,0x3b9accf1,0x3b9acd13,0x3b9acd21,0x3b9acd3d,0x3b9acd5d,0x3b9acd67,0x3b9acd7b,0x3b9acd85,0x3b9acd97,0x3b9acda3,0x3b9acda5,0x3b9acde1,0x3b9acdf3};",
            "int random_prime() {",
            "    shuffle(num.begin(), num.end(), gen);",
            "    int res=num.back();",
            "    num.pop_back();",
            "    return res;",
            "}"
        ],
        "description": "",
        "prefix": "#random_prime_1e9"
    },
    "[General] Time Duration": {
        "body": [
            "chrono::system_clock clock;",
            "auto t0=clock.now();",
            "${0:/* code */}",
            "chrono::duration<double,milli> dur=clock.now()-t0;",
            "cout<<\"Executed in \"<<dur.count()<<\" ms\"<<endl;"
        ],
        "description": "",
        "prefix": "#time"
    },
    "[Graph] Centroid": {
        "body": [
            "int sz[${1:N}],centroid[2];",
            "void get_centroid(int u,int fa,int tot) {",
            "    int maxx=0;",
            "    sz[u]=1;",
            "    for(int v:adj[u]) {",
            "        if(v!=fa) {",
            "            get_centroid(v,u,tot);",
            "            sz[u]+=sz[v];",
            "            maxx=max(maxx,sz[v]);",
            "        }",
            "    }",
            "    maxx=max(maxx,tot-sz[u]);",
            "    if(maxx<=tot/2) centroid[centroid[0]!=0]=u;",
            "}"
        ],
        "description": "",
        "prefix": "#centroid"
    },
    "[Graph] LCA (Binary Lifting)": {
        "body": [
            "constexpr int N=1e5+10,M=__lg(N);",
            "int fa[N][M+1],dep[N];",
            "",
            "void lca_init(int u,int p) {",
            "    dep[u]=dep[p]+1;",
            "    for(int v:adj[u]) {",
            "        if(v==p) continue;",
            "        fa[v][0]=u;",
            "        for(int i=1;i<=M;i++)",
            "            fa[v][i]=fa[fa[v][i-1]][i-1];",
            "        lca_init(v,u);",
            "    }",
            "}",
            "",
            "int lca(int u,int v) {",
            "    if(dep[u]<dep[v]) swap(u,v);",
            "    for(int k=M;~k;k--)",
            "        if(dep[fa[u][k]]>=dep[v])",
            "            u=fa[u][k];",
            "    if(u==v) return u;",
            "    for(int k=M;~k;k--)",
            "        if(fa[u][k]!=fa[v][k])",
            "            u=fa[u][k],v=fa[v][k];",
            "    return fa[u][0];",
            "}"
        ],
        "description": [
            "倍增求LCA O(nlogn)"
        ],
        "prefix": "#lca_binary_lifting"
    },
    "[Graph] LCA (Heavy-Light Decomposition)": {
        "body": [
            "namespace hpd {",
            "    constexpr int N=${1:1e5+10}; // ***",
            "    vector<int> adj[N];",
            "    int dep[N],sz[N],top[N],p[N],hch[N];",
            "",
            "    void dfs1(int u,int fa,int d) {",
            "        dep[u]=d,p[u]=fa,sz[u]=1;",
            "        for(int v:adj[u]) {",
            "            if(v==fa) continue;",
            "            dfs1(v,u,d+1);",
            "            sz[u]+=sz[v];",
            "            if(sz[hch[u]]<sz[v]) hch[u]=v;",
            "        }",
            "    }",
            "",
            "    void dfs2(int u,int t) {",
            "        top[u]=t;",
            "        if(!hch[u]) return;",
            "        dfs2(hch[u],t);",
            "        for(int v:adj[u])",
            "            if(v!=p[u]&&v!=hch[u]) dfs2(v,v);",
            "    }",
            "",
            "    int lca(int x,int y) {",
            "        while(top[x]!=top[y]) {",
            "            if(dep[top[x]]<dep[top[y]]) swap(x,y);",
            "            x=p[top[x]];",
            "        }",
            "        if(dep[x]<dep[y]) swap(x,y);",
            "        return y;",
            "    }",
            "",
            "    void init() {",
            "        dfs1(1,-1,1); dfs2(1,1);",
            "    }",
            "",
            "    void clear(int n) {",
            "        fill(hch, hch+n+1, 0);",
            "    }",
            "}"
        ],
        "description": "",
        "prefix": "#lca"
    },
    "[Graph] Maximum Flow": {
        "body": [
            "template<typename cap,int vertex,int edge> struct Flow {",
            "    constexpr static int N=vertex,M=edge;",
            "    constexpr static cap INF=cap(1)<<(8*sizeof(cap)-2);",
            "    int e[M],ne[M],idx;",
            "    int h[N],q[N],arc[N],d[N];",
            "    cap f[M];",
            "    int S,T=N-1;",
            "",
            "    void add_edge(int a,int b,cap c) {",
            "        e[idx]=b,f[idx]=c,ne[idx]=h[a],h[a]=idx++;",
            "        e[idx]=a,f[idx]=0,ne[idx]=h[b],h[b]=idx++;",
            "    }",
            "",
            "    cap dfs(int u,cap lim) {",
            "        if(u==T) return lim;",
            "        cap flow=0;",
            "        for(int i=arc[u];~i&&flow<lim;i=ne[i]){",
            "            int v=e[i];",
            "            arc[u]=i;",
            "            if(f[i]&&d[v]==d[u]+1){",
            "                cap t=dfs(v,min(f[i],lim-flow));",
            "                if(!t) d[v]=-1;",
            "                f[i]-=t,f[i^1]+=t,flow+=t;",
            "            }",
            "        }",
            "        return flow;",
            "    }",
            "",
            "    bool bfs() {",
            "        memset(d,-1,sizeof d);",
            "        q[0]=S,arc[S]=h[S],d[S]=0;",
            "        int hh=0,tt=1;",
            "        while(hh<tt) {",
            "            int ver=q[hh++];",
            "            for(int i=h[ver];~i;i=ne[i]) {",
            "                int t=e[i];",
            "                if(f[i]&&d[t]==-1) {",
            "                    d[t]=d[ver]+1;",
            "                    arc[t]=h[t];",
            "                    if(t==T) return 1;",
            "                    q[tt++]=t;",
            "                }",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    cap maxflow() {",
            "        cap F=0,flow=0;",
            "        while(bfs()) while(flow=dfs(S,INF)) F+=flow;",
            "        return F;",
            "    }",
            "",
            "    void init() {",
            "        idx=0;",
            "        memset(h, -1, sizeof h);",
            "    }",
            "",
            "    Flow() { init(); }",
            "};"
        ],
        "description": "Dinic maxflow",
        "prefix": "#maxflow"
    },
    "[Graph] Minimum Cost Maximum Flow": {
        "body": [
            "template<typename cap,typename cost,int vertex,int edge> struct Flow {",
            "    constexpr static int N=vertex,M=edge,INF=cap(1)<<(8*sizeof(cap)-2);",
            "    int S=0,T=N-1,idx;",
            "    int ne[M],e[M];",
            "    int h[N],q[N],pre[N];",
            "    cap f[M],mf[N];",
            "    cost d[N],w[M];",
            "    bool inq[N];",
            "",
            "    void add_edge(int a,int b,cap c,cost d) {",
            "        e[idx]=b,f[idx]=c,w[idx]=d,ne[idx]=h[a],h[a]=idx++;",
            "        e[idx]=a,f[idx]=0,w[idx]=-d,ne[idx]=h[b],h[b]=idx++;",
            "    }",
            "",
            "    bool spfa() {",
            "        memset(d,0x3f,sizeof d);",
            "        memset(mf,0,sizeof mf);",
            "        int hh=0,tt=1;",
            "        q[0]=S,d[S]=0,mf[S]=INF;",
            "        while(hh!=tt) {",
            "            int u=q[hh++];",
            "            if(hh==N) hh=0;",
            "            inq[u]=0;",
            "",
            "            for(int i=h[u];~i;i=ne[i]) {",
            "                int v=e[i];",
            "                if(f[i]&&d[v]>d[u]+w[i]) {",
            "                    d[v]=d[u]+w[i];",
            "                    pre[v]=i;",
            "                    mf[v]=min(mf[u],f[i]);",
            "                    if(!inq[v]){",
            "                        q[tt++]=v;",
            "                        if(tt==N) tt=0;",
            "                        inq[v]=1;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return mf[T]>0;",
            "    }",
            "",
            "    pair<cap,cost> maxflow() {",
            "        cap flow=0; cost val=0;",
            "        while(spfa()) {",
            "            flow+=mf[T],val+=mf[T]*d[T];",
            "            for(int i=T;i!=S;i=e[pre[i]^1]) {",
            "                f[pre[i]]-=mf[T];",
            "                f[pre[i]^1]+=mf[T];",
            "            }",
            "        }",
            "        return {flow,val};",
            "    }",
            "",
            "    void init() {",
            "        idx=0;",
            "        memset(h, -1, sizeof h);",
            "    }",
            "",
            "    Flow() { init(); }",
            "};"
        ],
        "description": "EK minimum cost maximum flow",
        "prefix": "#mincost_maxflow"
    },
    "[Graph] Tarjan": {
        "body": [
            "namespace scc {",
            "    int dfn[N],low[N],id[N],sz[N],scc_cnt,tsp;",
            "    vector<int> stk;",
            "    bool ins[N];",
            "",
            "    void tarjan(int u) {",
            "        dfn[u]=low[u]=++tsp;",
            "        stk.push_back(u),ins[u]=1;",
            "        for(int v:adj[u]) {",
            "            if(!dfn[v]) {",
            "                tarjan(v);",
            "                low[u]=min(low[u],low[v]);",
            "            }",
            "            else if(ins[v]) low[u]=min(low[u],dfn[v]);",
            "        }",
            "        if(dfn[u]==low[u]) {",
            "            scc_cnt++;",
            "            int x;",
            "            do {",
            "                x=stk.back();",
            "                stk.pop_back();",
            "                ins[x]=0;",
            "                id[x]=scc_cnt;",
            "                sz[scc_cnt]++;",
            "            } while(x!=u);",
            "        }",
            "    }",
            "",
            "    void init(int n) {",
            "        if(tsp) {",
            "            scc_cnt=tsp=0;",
            "            for(int i=1;i<=n;i++) dfn[i]=sz[i]=0;",
            "        }",
            "        for(int i=1;i<=n;i++) if(!dfn[i]) tarjan(i);",
            "    }",
            "} using scc::id,scc::sz,scc::scc_cnt;"
        ],
        "description": "",
        "prefix": "#tarjan"
    },
    "[Math] Combinatorial Number": {
        "body": [
            "constexpr int N=${1:1e5+10};",
            "LL faet[N],infaet[N];",
            "",
            "LL qpow(LL a,LL b) {",
            "    LL  res=1;",
            "    while(b){",
            "        if(b&1) res=res*a%mod;",
            "        b>>=1;",
            "        a=a*a%mod;",
            "    }",
            "    return res;",
            "}",
            "",
            "void init() {",
            "    faet[1]=1,faet[0]=1;",
            "    infaet[1]=1,infaet[0]=1;",
            "    for(int i=2;i<N;i++) {",
            "        faet[i]=faet[i-1]*i%mod;",
            "        infaet[i]=infaet[i-1]*qpow(i,mod-2)%mod;",
            "    }",
            "}",
            "",
            "LL get(int a,int b) {",
            "    if(a<0||b<0||a<b) return 0;",
            "    return faet[a]*infaet[a-b]%mod*infaet[b]%mod;",
            "}"
        ],
        "description": "递推求组合数 O(n)",
        "prefix": "#cmb_mod"
    },
    "[Math] Combinatorial Number with Modint": {
        "body": [
            "struct Binom {",
            "    vector<Mint> faet,infaet;",
            "",
            "    Mint operator()(int n,int m) {",
            "        if(n<0||m<0||n<m) return {};",
            "        return faet[n]*infaet[n-m]*infaet[m];",
            "    }",
            "",
            "    explicit Binom(int sz) {",
            "        faet.resize(sz+1);",
            "        infaet.resize(sz+1);",
            "",
            "        faet[0]=faet[1]=1;",
            "        infaet[0]=infaet[1]=1;",
            "        for(int i=2;i<=sz;i++){",
            "            faet[i]=faet[i-1]*i;",
            "            infaet[i]=infaet[i-1]/i;",
            "        }",
            "    }",
            "} binom(N);"
        ],
        "description": "递推求组合数 O(n)",
        "prefix": [
            "#binom",
            "#cmb"
        ]
    },
    "[Math] Euler's Sieve": {
        "body": [
            "constexpr int M=${1:1e6+10};",
            "int prime[M],idx;",
            "bool isnp[M];",
            "",
            "void get_prime(int n=M-1) {",
            "    isnp[1]=1;",
            "    for(int i=2;i<=n;i++) {",
            "        if(!isnp[i]) prime[++idx]=i;",
            "        for(int j=1;prime[j]<=n/i;j++) {",
            "            isnp[prime[j]*i]=true;",
            "            if(i%prime[j]==0) break;",
            "        }",
            "    }",
            "}"
        ],
        "description": "线性筛 O(n)",
        "prefix": "#prime_sieve"
    },
    "[Math] Euler's Totient Function": {
        "body": [
            "constexpr int M=${1:1e6+10};",
            "int prime[M],phi[M],idx;",
            "bool isnp[M];",
            "",
            "void get_prime(int n=M-1) {",
            "    isnp[1]=phi[1]=1;",
            "    for(int i=2;i<=n;i++) {",
            "        if(!isnp[i]) prime[++idx]=i,phi[i]=i-1;",
            "        for(int j=1;prime[j]<=n/i;j++) {",
            "            isnp[prime[j]*i]=true;",
            "            if(i%prime[j]==0) {",
            "                phi[i*prime[j]]=phi[i]*prime[j];",
            "                break;",
            "            }",
            "            else phi[i*prime[j]]=phi[i]*(prime[j]-1);",
            "        }",
            "    }",
            "}"
        ],
        "description": [
            "线性筛求欧拉函数 O(n)",
            "phi[i] 表示 小于等于i和i互质的个数"
        ],
        "prefix": "#euler_func"
    },
    "[Math] Exgcd": {
        "body": [
            "template<typename T> T exgcd(T a,T b,T &x,T &y) {",
            "    if(!b) { x=1,y=0; return a; }",
            "    T res=exgcd(b, a%b, x, y),t=x;",
            "    x=y,y=t-(a/b)*y;",
            "    return res;",
            "}"
        ],
        "description": [
            "Extended Euclidean algorithm",
            "计算 ax+by=gcd(a,b) 的一组解 返回gcd(a,b)",
            "如果是计算 ax+by=c 的一组解,那么将x,y再乘上c/gcd(a,b)即可,当且仅当 gcd(a,b)|c 时有解",
            "此外,x,y的通解形式分别为x+kb/gcd(a,b),y-ka/gcd(a,b)"
        ],
        "prefix": "#exgcd"
    },
    "[Math] Factorization": {
        "body": [
            "template<typename T> vector<T> get_prime_factor(T x) {",
            "    vector<T> res;",
            "    for(T i=2;i*i<=x;i++) {",
            "        if(x%i==0) {",
            "            while(x%i==0) x/=i;",
            "            res.push_back(i);",
            "        }",
            "    }",
            "    if(x>1) res.push_back(x);",
            "    return res;",
            "}",
            "",
            "template<typename T> vector<T> get_factor(T x) {",
            "    vector<T> res;",
            "    for(T i=1;i*i<=x;i++) {",
            "        if(x%i==0) {",
            "            res.push_back(i);",
            "            if(x/i!=i) res.push_back(x/i);",
            "        }",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "因数分解/质因数分解 O(sqrt(n))",
        "prefix": "#factorization"
    },
    "[Math] Matrix": {
        "body": [
            "template<typename T,int R,int C=R> struct Matrix {",
            "    array<array<T,C>,R> v;",
            "    ",
            "    template<int Rr,int Cr> constexpr Matrix<T,R,Cr> ",
            "    operator*(const Matrix<T,Rr,Cr> &r) const {",
            "        static_assert(C==Rr,\"\");",
            "        array<array<T,Cr>,R> ans{};",
            "        for(int i=0;i<R;i++) {",
            "            for(int k=0;k<C;k++) {",
            "                // if(v[i][k]==0) continue;",
            "                for(int j=0;j<Cr;j++) {",
            "                    ans[i][j]+=v[i][k]*r[k][j];",
            "                }",
            "            }",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    constexpr Matrix operator+(const Matrix &r) const {",
            "        array<array<T,C>,R> ans{};",
            "        for(int i=0;i<R;i++)",
            "            for(int j=0;j<C;j++)",
            "                ans[i][j]=v[i][j]+r[i][j];",
            "        return ans;",
            "    }",
            "",
            "    constexpr Matrix operator-(const Matrix &r) const {",
            "        array<array<T,C>,R> ans{};",
            "        for(int i=0;i<R;i++)",
            "            for(int j=0;j<C;j++)",
            "                ans[i][j]=v[i][j]-r[i][j];",
            "        return ans;",
            "    }",
            "",
            "    constexpr Matrix &operator*=(const Matrix<T,C,C> &r) { return *this=*this*r; }",
            "    constexpr Matrix &operator+=(const Matrix &r) { return *this=*this+r; }",
            "    constexpr Matrix &operator-=(const Matrix &r) { return *this=*this-r; }",
            "",
            "    constexpr Matrix pow(long long k) const {",
            "        Matrix res(1),x=*this;",
            "        while(k) { if(k&1) res*=x; k>>=1; x*=x; }",
            "        return res;",
            "    }",
            "",
            "    constexpr auto &operator[](int idx) { return v[idx]; }",
            "    constexpr auto &operator[](int idx) const { return v[idx]; }",
            "",
            "    constexpr void clear() { v={}; }",
            "    constexpr void unit(T x=1) {",
            "        static_assert(R==C,\"\");",
            "        clear(); for(int i=0;i<R;i++) v[i][i]=x;",
            "    }",
            "",
            "    constexpr Matrix() { clear(); }",
            "    constexpr Matrix(T x) { unit(x); }",
            "    constexpr Matrix(const array<array<T,C>,R> &x): v(x) {}",
            "};"
        ],
        "description": "Matrix",
        "prefix": "#matrix"
    },
    "[Math] Modint": {
        "body": [
            "template<typename I,typename L,I mod> struct Modint {",
            "    I v;",
            "    constexpr I pow(L b) const {",
            "        L res=1,a=v;",
            "        while(b) { if(b&1) res=res*a%mod; b>>=1; a=a*a%mod; }",
            "        return res;",
            "    }",
            "    constexpr I inv() const { return pow(mod-2); }",
            "",
            "    constexpr Modint &operator+=(const Modint &x) { v+=x.v; v-=v>=mod?mod:0; return *this; }",
            "    constexpr Modint &operator-=(const Modint &x) { v-=x.v; v+=v<0?mod:0; return *this; }",
            "    constexpr Modint &operator*=(const Modint &x) { v=L(1)*v*x.v%mod; return *this; }",
            "    constexpr Modint &operator/=(const Modint &x) { v=L(1)*v*x.inv()%mod; return *this; }",
            "",
            "    friend constexpr Modint operator+(Modint l,const Modint &r) { return l+=r; }",
            "    friend constexpr Modint operator-(Modint l,const Modint &r) { return l-=r; }",
            "    friend constexpr Modint operator*(Modint l,const Modint &r) { return l*=r; }",
            "    friend constexpr Modint operator/(Modint l,const Modint &r) { return l/=r; }",
            "    friend constexpr Modint operator-(Modint r) { r.v=mod-r.v; return r; }",
            "",
            "    Modint operator++(int) { auto res=*this; ++*this; return res; }",
            "    Modint operator--(int) { auto res=*this; --*this; return res; }",
            "    Modint &operator++() { v=v==mod-1?0:v+1; return *this; }",
            "    Modint &operator--() { v=v?v-1:mod-1; return *this; }",
            "",
            "    constexpr bool operator< (const Modint &x) const { return v< x.v; }",
            "    constexpr bool operator> (const Modint &x) const { return v> x.v; }",
            "    constexpr bool operator<=(const Modint &x) const { return v<=x.v; }",
            "    constexpr bool operator>=(const Modint &x) const { return v>=x.v; }",
            "    constexpr bool operator==(const Modint &x) const { return v==x.v; }",
            "    constexpr bool operator!=(const Modint &x) const { return v!=x.v; }",
            "",
            "    friend istream &operator>>(istream &is,Modint &x) { is>>x.v; x=Modint(x.v); return is; }",
            "    friend ostream &operator<<(ostream &os,const Modint &x) { return os<<x.v; }",
            "",
            "    constexpr Modint(L x=0): v((x%=mod)<0?x+mod:x) {}",
            "}; using Mint=Modint<int,long long,${1|998244353,int(1e9)+7|}>;"
        ],
        "description": "Modulo Automation",
        "prefix": "#modint"
    },
    "[Math] Numeric Sqrt-decomposition": {
        "body": [
            "int next_floor(int k,int i) {",
            "    return k/(k/i);",
            "}",
            "",
            "int next_ceil(int k,int i) {",
            "    if(k-1<i) return i;",
            "    return (k-1)/((k-1)/i);",
            "}"
        ],
        "description": "数论分块",
        "prefix": "#sqrt-decomposition"
    },
    "[Math] Prime Factorization": {
        "body": [
            "constexpr int M=${1:1e6+10};",
            "int prime[M],minp[M],idx;",
            "bool isnp[M];",
            "",
            "void get_prime(int n=M-1) {",
            "    isnp[1]=minp[1]=1;",
            "    for(int i=2;i<=n;i++) {",
            "        if(!isnp[i]) prime[++idx]=i,minp[i]=i;",
            "        for(int j=1;prime[j]<=n/i;j++) {",
            "            isnp[prime[j]*i]=true;",
            "            minp[prime[j]*i]=prime[j];",
            "            if(i%prime[j]==0) break;",
            "        }",
            "    }",
            "}",
            "",
            "vector<int> get_factor(int val) {",
            "    vector<int> res;",
            "    while(val>1) {",
            "        int t=minp[val];",
            "        res.push_back(t);",
            "        while(minp[val]==t) val/=t;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "质因数分解 O(logn)",
        "prefix": "#prime_factorization"
    },
    "[Math] Quick Power": {
        "body": [
            "LL qpow(LL a,LL b) {",
            "    LL res=1;",
            "    while(b) {",
            "        if(b&1) res=res*a${1:%mod};",
            "        b>>=1;",
            "        a=a*a${1:%mod};",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "quick power O(logn)",
        "prefix": "#qpow"
    },
    "[Misc] SGT D&Q": {
        "body": [
            "namespace sd {",
            "    #define lch (u<<1)",
            "    #define rch (u<<1|1)",
            "    using T=int;",
            "    vector<vector<T>> seg;",
            "    int rng_l,rng_r;",
            "",
            "    void add(int u,int x,int y,int l,int r,T val) {",
            "        if(x>r||y<l) return;",
            "        if(x<=l&&y>=r) seg[u].emplace_back(val);",
            "        else {",
            "            int mid=(l+r)/2;",
            "            add(lch,x,y,l,mid,val);",
            "            add(rch,x,y,mid+1,r,val);",
            "        }",
            "    }",
            "    void add(int x,int y,T val) {",
            "        add(1,x,y,rng_l,rng_r,val);",
            "    }",
            "",
            "    void solve(int u,int l,int r) {",
            "        // apply",
            "        for(auto x:seg[u]) {",
            "            ",
            "        }",
            "",
            "        // update ans",
            "        if(l==r) ;",
            "        else {",
            "            int mid=(l+r)/2;",
            "            solve(lch,l,mid);",
            "            solve(rch,mid+1,r);",
            "        }",
            "",
            "        // undo",
            "    }",
            "    void solve() {",
            "        solve(1,rng_l,rng_r);",
            "    }",
            "",
            "    void init(int l,int r) {",
            "        rng_l=l,rng_r=r;",
            "        seg.clear();",
            "        seg.resize(4<<__lg(r-l+1)|1);",
            "    }",
            "",
            "    #undef lch",
            "    #undef rch",
            "}"
        ],
        "description": [
            "线段树分治\n",
            "能在至多增加一个log的代价下\n",
            "将[增删]转化为[增+撤销]或[增+持久化]\n",
            "问题必须可离线"
        ],
        "prefix": "#sgt_div"
    },
    "[Misc] CDQ's Divide and Conquer": {
        "body": [
            "namespace cdq {",
            "    constexpr int N=${1:1e5+10}; // ***",
            "    struct Point {",
            "        ",
            "        bool operator<(const Point &p) const {",
            "            ",
            "        }",
            "    } p[N],tmp[N],bak[N];",
            "",
            "    void solve(const int L,const int R) {",
            "        if(L==R) return;",
            "        int mid=L+R>>1;",
            "        solve(L,mid),solve(mid+1,R);",
            "",
            "        int i=L,j=mid+1,idx=L;",
            "        while(j<=R) {",
            "            while(i<=mid&&true) {",
            "                // TODO 双指针更新i",
            "                tmp[idx++]=p[i++];",
            "            }",
            "            // TODO 更新答案",
            "            tmp[idx++]=p[j++];",
            "        }",
            "        for(int k=L;k<i;k++) ; // TODO reset状态",
            "        while(i<=mid) tmp[idx++]=p[i++];",
            "        for(int i=L;i<=R;i++) p[i]=tmp[i];",
            "    }",
            "",
            "} using cdq::p,cdq::bak;"
        ],
        "description": [
            "CDQ 分治",
            "如果要求转移有序,则必须先solve(l,mid),再处理当前区间信息合并,最后solve(mid+1,r),并且基本上难以归并排序,应当直接sort()"
        ],
        "prefix": "#cdq"
    },
    "[Misc] Centroid Decomposition": {
        "body": [
            "namespace cd {",
            "    constexpr int N=${1:1e5+10}; // ***",
            "    int sz[N],centroid[2];",
            "    vector<int> adj[N];",
            "    bool del[N];",
            "",
            "    void get_centroid(int u,int fa,int tot) {",
            "        int maxx=0;",
            "        sz[u]=1;",
            "        for(int v:adj[u]) {",
            "            if(v!=fa&&!del[v]) {",
            "                get_centroid(v,u,tot);",
            "                sz[u]+=sz[v];",
            "                maxx=max(maxx,sz[v]);",
            "            }",
            "        }",
            "        maxx=max(maxx,tot-sz[u]);",
            "        if(maxx<=tot/2) centroid[centroid[0]!=0]=u;",
            "    }",
            "",
            "    void solve(int _u,int tot) {",
            "        centroid[0]=centroid[1]=0;",
            "        get_centroid(_u, -1, tot);",
            "        int u=centroid[0];",
            "        get_centroid(u, -1, tot);",
            "        del[u]=1;",
            "",
            "        for(int v:adj[u]) {",
            "            if(!del[v]) {",
            "                // TODO",
            "            }",
            "        }",
            "",
            "        for(int v:adj[u]) if(!del[v]) solve(v, sz[v]);",
            "    }",
            "",
            "    void clear(int n) {",
            "        fill(del,del+1+n,0);",
            "        for(int i=1;i<=n;i++) adj[i].clear();",
            "    }",
            "}"
        ],
        "description": "点分治",
        "prefix": "#centroid_decomposition"
    },
    "[Misc] Discrete": {
        "body": [
            "sort(${1:num}.begin(),${1:num}.end());",
            "${1:num}.erase(unique(${1:num}.begin(),${1:num}.end()),${1:num}.end());",
            "for(int i=1;i<=n;i++) ",
            "    ${2:arr}[i]=lower_bound(${1:num}.begin(),${1:num}.end(),${2:arr}[i])-${1:num}.begin()+1;",
            ""
        ],
        "description": "离散化 (排序+二分) O(nlogn)",
        "prefix": "#discrete"
    },
    "[Misc] Dsu on Tree": {
        "body": [
            "namespace dsu {",
            "    constexpr int N=${1:1e5+10}; // ***",
            "    int id[N],ed[N],ori[N],sz[N],hch[N],idx;",
            "    vector<int> adj[N];",
            "",
            "    void init(int u,int fa) {",
            "        sz[u]=1;",
            "        id[u]=++idx;",
            "        ori[id[u]]=u;",
            "        for(int v:adj[u]) {",
            "            if(v!=fa) {",
            "                init(v,u);",
            "                if(sz[v]>sz[hch[u]]) hch[u]=v;",
            "                sz[u]+=sz[v];",
            "            }",
            "        }",
            "        ed[u]=idx;",
            "    }",
            "",
            "    void solve(int u,int fa,bool keep) {",
            "        auto add=[](int id) {",
            "            int x=ori[id];",
            "            ",
            "        };",
            "",
            "        auto del=[](int id) {",
            "            int x=ori[id];",
            "            ",
            "        };",
            "        ",
            "        for(int v:adj[u]) if(v!=fa&&v!=hch[u]) solve(v,u,0);",
            "        if(hch[u]) solve(hch[u],u,1);",
            "        for(int v:adj[u]) ",
            "            if(v!=fa&&v!=hch[u]) ",
            "                for(int i=id[v];i<=ed[v];i++) add(i);",
            "        add(id[u]);",
            "        ",
            "        // TODO update ans",
            "",
            "        if(!keep) for(int i=id[u];i<=ed[u];i++) del(i);",
            "    }",
            "",
            "    void clear(int n=N-1) {",
            "        idx=0;",
            "        fill(hch,hch+n+1,0);",
            "        for(int i=0;i<=n;i++) adj[i].clear();",
            "    }",
            "}"
        ],
        "description": "dsu on tree",
        "prefix": "#dsu_on_tree"
    },
    "[Misc] Hash Array": {
        "body": [
            "struct HashArray {",
            "    constexpr static int base=131;",
            "    vector<Hint> arr,pw;",
            "",
            "    void push_back(int x) {",
            "        arr.push_back(arr.back()*base+x);",
            "        pw.push_back(pw.back()*base);",
            "    }",
            "",
            "    void append(string &s) { for(auto x:s) push_back(x); }",
            "    void append(vector<int> &s) { for(auto x:s) push_back(x); }",
            "",
            "    Hint query(int l,int r) {",
            "        return arr[r]-arr[l-1]*pw[r-l+1];",
            "    }",
            "",
            "    void clear() { arr.clear(),pw.clear();arr.push_back(0),pw.push_back(1); }",
            "    ",
            "    HashArray() { clear(); };",
            "    HashArray(int sz) {",
            "        clear();",
            "        arr.reserve(sz),pw.reserve(sz);",
            "    };",
            "};"
        ],
        "description": "Hash Array",
        "prefix": "#hash_array"
    },
    "[Misc] Hash of Tree": {
        // xorshift版本
        "body": [
            "struct Hasher {",
            "    ULL rnd;",
            "",
            "    ULL operator()(ULL x) {",
            "        x^=rnd;",
            "        x^=x<<13;",
            "        x^=x>>7;",
            "        x^=x<<13;",
            "        x^=rnd;",
            "        return x;",
            "    }",
            "",
            "    Hasher() {",
            "        mt19937 gen(random_device{}());",
            "        rnd=gen();",
            "    }",
            "} f;"
        ],
        // 邓老师版本
        // 原版中两个rnd的参数为1237123和19260817
        // "body": [
        // 	"struct Hasher {",
        // 	"    LL rnd1,rnd2;",
        // 	"",
        // 	"    LL operator()(LL x) {",
        // 	"        auto h=[&](LL x) {",
        // 	"            return x * x * x * rnd1 + rnd2;",
        // 	"        };",
        // 	"        LL res = h(x & ((1LL << 31) - 1)) + h(x >> 31);",
        // 	"        return res;",
        // 	"    }",
        // 	"",
        // 	"    Hasher() {",
        // 	"        mt19937 gen(random_device{}());",
        // 	"        rnd1=gen(),rnd2=gen();",
        // 	"    }",
        // 	"} f;",
        // ],
        "description": "hash of tree",
        "prefix": "#hashtree"
    },
    "[Misc] Hashint": {
        "body": [
            "constexpr int HASHCNT=2;",
            "array<int,HASHCNT> mod;",
            "template<int size,typename I=int,typename L=long long,const array<I,size> &p=mod> struct Hashint {",
            "    array<I,size> v;",
            "    I _pow(int i,L b) const {",
            "        L res=1,a=v[i];",
            "        while(b) { if(b&1) res=res*a%p[i]; b>>=1; a=a*a%p[i]; }",
            "        return res;",
            "    }",
            "    I _inv(int i) const { return _pow(i,p[i]-2); }",
            "    Hashint pow(L b) {",
            "        Hashint res;",
            "        for(int i=0;i<size;i++) res[i]=_pow(i,b);",
            "        return res;",
            "    }",
            "",
            "    Hashint &operator+=(const Hashint &x) { for(int i=0;i<size;i++) v[i]+=x[i],v[i]-=v[i]>=p[i]?p[i]:0; return *this; }",
            "    Hashint &operator-=(const Hashint &x) { for(int i=0;i<size;i++) v[i]-=x[i],v[i]+=v[i]<0?p[i]:0; return *this; }",
            "    Hashint &operator*=(const Hashint &x) { for(int i=0;i<size;i++) v[i]=L(1)*v[i]*x[i]%p[i]; return *this; }",
            "    Hashint &operator/=(const Hashint &x) { for(int i=0;i<size;i++) v[i]=L(1)*v[i]*x._inv(i)%p[i]; return *this; }",
            "",
            "    friend Hashint operator+(Hashint l,const Hashint &r) { return l+=r; }",
            "    friend Hashint operator-(Hashint l,const Hashint &r) { return l-=r; }",
            "    friend Hashint operator*(Hashint l,const Hashint &r) { return l*=r; }",
            "    friend Hashint operator/(Hashint l,const Hashint &r) { return l/=r; }",
            "    ",
            "    Hashint operator++(int) { auto res=*this; *this+=1; return res; }",
            "    Hashint operator--(int) { auto res=*this; *this-=1; return res; }",
            "    Hashint operator-  () { return *this*-1; }",
            "    Hashint &operator++() { return *this+=1; }",
            "    Hashint &operator--() { return *this-=1; }",
            "",
            "    bool operator< (const Hashint &x) const { return v< x.v; }",
            "    bool operator> (const Hashint &x) const { return v> x.v; }",
            "    bool operator<=(const Hashint &x) const { return v<=x.v; }",
            "    bool operator>=(const Hashint &x) const { return v>=x.v; }",
            "    bool operator==(const Hashint &x) const { return v==x.v; }",
            "    bool operator!=(const Hashint &x) const { return v!=x.v; }",
            "",
            "    auto &operator[](int i) { return v[i]; }",
            "    auto &operator[](int i) const { return v[i]; }",
            "",
            "    Hashint(L x=0) { for(int i=0;i<size;i++) v[i]=(x%p[i]+p[i])%p[i]; }",
            "}; using Hint=Hashint<HASHCNT>;"
        ],
        "description": "",
        "prefix": "#hashint"
    },
    //====algorithm:basic & misc====//
    "[Misc] Lowbit": {
        "body": [
            "#define lowbit(x) (x&(-x))"
        ],
        "description": "get the lowest bit of x",
        "prefix": "#lowbit"
    },
    "[Misc] Mo's Algorithm": {
        "body": [
            "namespace mo {",
            "    constexpr int N=${1:1e5+10},Q=${2:1e5+10},block=${3:320};",
            "    using Query=tuple<int,int,int>;",
            "    vector<Query> query;",
            "    int ans[Q];",
            "    ",
            "    void solve() {",
            "        auto getid=[](int x) {",
            "            return x/block;",
            "        };",
            "",
            "        sort(query.begin(),query.end(),[&](const Query &x,const Query &y) {",
            "            const auto &[l,r,_]=x;",
            "            const auto &[L,R,__]=y;",
            "            if(getid(l)!=getid(L)) return getid(l)<getid(L);",
            "            return getid(l)&1?r<R:r>R;",
            "        });",
            "",
            "        int l=1,r=0,res=0;",
            "        ",
            "        auto add=[&](int idx) {",
            "            ",
            "        };",
            "",
            "        auto del=[&](int idx) {",
            "            ",
            "        };",
            "        ",
            "        for(const auto &[L,R,id]:query) {",
            "            while(l>L) add(--l);",
            "            while(r<R) add(++r);",
            "            while(l<L) del(l++);",
            "            while(r>R) del(r--);",
            "            // TODO ans[id]=res;",
            "        }",
            "    }",
            "}"
        ],
        "description": [
            "莫队\n",
            "块大小平衡点为block=sqrt(N^2/Q)\n",
            "[时间复杂度] O(n sqrt(q)+qlogq)\n"
        ],
        "prefix": "#mo_algo"
    },
    "[Misc] Mo's Algorithm on tree": {
        "body": [
            "namespace mo {",
            "    constexpr int N=${1:5e4+10},Q=${2:1e5+10},block=${3:320}; // ***",
            "    using Query=tuple<int,int,int,int>;",
            "    vector<Query> query;",
            "    vector<int> adj[N];",
            "    int uid[N<<1],first[N],last[N],idx;",
            "    bool odd[N];",
            "    int ans[Q];",
            "    ",
            "    namespace hpd {",
            "        int dep[N],sz[N],top[N],p[N],hch[N];",
            "    ",
            "        void dfs1(int u,int fa,int d) {",
            "            dep[u]=d,p[u]=fa,sz[u]=1;",
            "            for(int v:adj[u]) {",
            "                if(v==fa) continue;",
            "                dfs1(v,u,d+1);",
            "                sz[u]+=sz[v];",
            "                if(sz[hch[u]]<sz[v]) hch[u]=v;",
            "            }",
            "        }",
            "    ",
            "        void dfs2(int u,int t) {",
            "            top[u]=t;",
            "            if(!hch[u]) return;",
            "            dfs2(hch[u],t);",
            "            for(int v:adj[u])",
            "                if(v!=p[u]&&v!=hch[u]) dfs2(v,v);",
            "        }",
            "    ",
            "        int lca(int x,int y) {",
            "            while(top[x]!=top[y]) {",
            "                if(dep[top[x]]<dep[top[y]]) swap(x,y);",
            "                x=p[top[x]];",
            "            }",
            "            if(dep[x]<dep[y]) swap(x,y);",
            "            return y;",
            "        }",
            "    ",
            "        void init() {",
            "            dfs1(1,-1,1); dfs2(1,1);",
            "        }",
            "",
            "        void clear(int n) {",
            "            fill(hch, hch+n+1, 0);",
            "        }",
            "    }",
            "",
            "    void dfs(int u,int fa) {",
            "        uid[++idx]=u;",
            "        first[u]=idx;",
            "        for(int v:adj[u]) if(v!=fa) dfs(v,u);",
            "        uid[++idx]=u;",
            "        last[u]=idx;",
            "    }",
            "",
            "    void add_query(int u,int v,int id) {",
            "        if(first[u]>first[v]) swap(u,v);",
            "        int p=hpd::lca(u,v);",
            "        int l,r,pidx;",
            "        if(u==p) l=first[u],r=first[v],pidx=0;",
            "        else l=last[u],r=first[v],pidx=first[p];",
            "        query.emplace_back(l,r,pidx,id);",
            "    }",
            "",
            "    void solve() {",
            "        auto getid=[](int x) {",
            "            return x/block;",
            "        };",
            "",
            "        sort(query.begin(),query.end(),[&](const Query &x,const Query &y) {",
            "            const auto &[l,r,_,__]=x;",
            "            const auto &[L,R,___,____]=y;",
            "            if(getid(l)!=getid(L)) return getid(l)<getid(L);",
            "            return getid(l)&1?r<R:r>R;",
            "        });",
            "",
            "        auto _add=[&](int u) {",
            "            ",
            "        };",
            "",
            "        auto _del=[&](int u) {",
            "            ",
            "        };",
            "",
            "        auto extend=[&](int idx) {",
            "            int u=uid[idx];",
            "            if(odd[u]^=1) _add(u);",
            "            else _del(u);",
            "        };",
            "",
            "        int l=1,r=0;",
            "        for(const auto &[L,R,pidx,id]:query) {",
            "            while(l>L) extend(--l);",
            "            while(r<R) extend(++r);",
            "            while(l<L) extend(l++);",
            "            while(r>R) extend(r--);",
            "            if(pidx) extend(pidx);",
            "            // TODO ans[id]=res;",
            "            if(pidx) extend(pidx);",
            "        }",
            "    }",
            "",
            "    void init() {",
            "        hpd::init();",
            "        dfs(1,-1);",
            "    }",
            "",
            "    void clear(int n) {",
            "        idx=0;",
            "        query.clear();",
            "        fill(odd, odd+n+1, 0);",
            "        for(int i=0;i<=n;i++) adj[i].clear();",
            "        hpd::clear(n);",
            "    }",
            "}"
        ],
        "description": [
            "树上莫队\n",
            "块大小平衡点为block=2sqrt(N^2/Q)\n",
            "[时间复杂度] O(n sqrt(q)+qlogq)\n"
        ],
        "prefix": "#mo_tree"
    },
    "[Misc] Mo's Algorithm, modifiable version": {
        "body": [
            "namespace mo {",
            "    constexpr int N=${1:1e5+10},Q=${2:1e5+10},block=${3:2155};",
            "    using Query=tuple<int,int,int,int>;",
            "    vector<Query> query;",
            "    int ans[Q];",
            "    ",
            "    void solve() {",
            "        auto getid=[](int x) {",
            "            return x/block;",
            "        };",
            "",
            "        sort(query.begin(),query.end(),[&](const Query &x,const Query &y) {",
            "            const auto &[l,r,t,_]=x;",
            "            const auto &[L,R,T,__]=y;",
            "            if(getid(l)!=getid(L)) return getid(l)<getid(L);",
            "            if(getid(r)!=getid(R)) return getid(r)<getid(R);",
            "            return t<T;",
            "        });",
            "",
            "        int l=1,r=0,tm=0;",
            "        ",
            "        auto add=[&](int idx) {",
            "            ",
            "        };",
            "",
            "        auto del=[&](int idx) {",
            "            ",
            "        };",
            "",
            "        auto modify=[&](int t) {",
            "            // int idx=pos[t];",
            "            // if(idx>=l&&idx<=r) del(idx);",
            "            // swap(w[idx],nw[t]);",
            "            // if(idx>=l&&idx<=r) add(idx);",
            "        };",
            "",
            "        auto rollback=[&](int t) {",
            "            modify(t);",
            "        };",
            "        ",
            "        for(const auto &[L,R,T,id]:query) {",
            "            while(l>L) add(--l);",
            "            while(r<R) add(++r);",
            "            while(l<L) del(l++);",
            "            while(r>R) del(r--);",
            "            while(tm<T) modify(++tm);",
            "            while(tm>T) rollback(tm--);",
            "            // TODO ans[id]=res;",
            "        }",
            "    }",
            "}"
        ],
        "description": [
            "带修莫队\n",
            "块大小平衡点为block=cbrt(n^2) 设询问与修改次数同阶\n",
            "[时间复杂度] O(n^(5/3)+qlogq)"
        ],
        "prefix": "#mo_algo_modifiable"
    },
    "[Misc] Mo's Algorithm, rollback version": {
        "body": [
            "namespace mo {",
            "    constexpr int N=${1:1e5+10},Q=${2:1e5+10},block=${3:320}; // ***",
            "    using Query=tuple<int,int,int>;",
            "    vector<Query> query;",
            "    int ans[Q];",
            "    ",
            "    void solve(int n) {",
            "        auto getid=[](int x) {",
            "            return x/block;",
            "        };",
            "        auto getr=[&](int id) {",
            "            return min(id*block+block-1,n);",
            "        };",
            "",
            "        sort(query.begin(),query.end(),[&](const Query &x,const Query &y) {",
            "            const auto &[l,r,_]=x;",
            "            const auto &[L,R,__]=y;",
            "            if(getid(l)!=getid(L)) return getid(l)<getid(L);",
            "            return r<R;",
            "        });",
            "",
            "        int l=1,r=0,lastid=-1,rbd=0;",
            "",
            "        auto add=[&](int idx) {",
            "            ",
            "        };",
            "",
            "        auto del=[&](int idx) {",
            "            ",
            "        };",
            "",
            "        auto reset=[&]() {",
            "            while(r<rbd) add(++r);",
            "            while(r>rbd) del(r--);",
            "            while(l<=rbd) del(l++);",
            "            // res=bak=0;",
            "        };",
            "        ",
            "        for(const auto &[L,R,id]:query) {",
            "            if(getid(L)!=lastid) {",
            "                lastid=getid(L);",
            "                rbd=getr(lastid);",
            "                reset();",
            "            }",
            "",
            "            if(getid(L)==getid(R)) {",
            "                // bak=res;",
            "                for(int i=L;i<=R;i++) add(i);",
            "                // ans[id]=res;",
            "                for(int i=L;i<=R;i++) del(i);",
            "                // res=bak;",
            "            }",
            "            else {",
            "                while(r<R) add(++r);",
            "                // bak=res;",
            "                while(l>L) add(--l);",
            "                // ans[id]=res;",
            "                while(l<=rbd) del(l++);",
            "                // res=bak;",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": [
            "回滚莫队（只增莫队）\n",
            "块大小平衡点为block=sqrt(N^2/Q)\n",
            "[时间复杂度] O(n sqrt(q)+qlogq)\n"
        ],
        "prefix": "#mo_algo_rollback"
    },
    "[String] Aho-Corasick Automaton": {
        "body": [
            "struct AhoCorasickAutomaton {",
            "    constexpr static int A=26;",
            "    constexpr static char B='a';",
            "    struct Node {",
            "        int link,cnt;",
            "        int ch[A];",
            "    };",
            "",
            "    vector<Node> tr;",
            "    int sz=0;",
            "",
            "    int insert(string &s) {",
            "        int root=0;",
            "        for(auto x:s) {",
            "            int c=x-B;",
            "            if(!tr[root].ch[c]) ",
            "                tr[root].ch[c]=new_node();",
            "            root=tr[root].ch[c];",
            "        }",
            "        tr[root].cnt++;",
            "        return root;",
            "    }",
            "",
            "    void build() {",
            "        queue<int> q;",
            "        for(int i=0;i<A;i++) ",
            "            if(tr[0].ch[i]) {",
            "                q.push(tr[0].ch[i]);",
            "",
            "            }",
            "        while(q.size()) {",
            "            auto root=q.front();",
            "            q.pop();",
            "            for(int i=0;i<A;i++) {",
            "                int &cur=tr[root].ch[i];",
            "                int pre=tr[tr[root].link].ch[i];",
            "                if(!cur) cur=pre;",
            "                else {",
            "                    // tr[cur].cnt+=tr[pre].cnt;",
            "                    tr[cur].link=pre;",
            "                    q.push(cur);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    int match() {",
            "",
            "    }",
            "",
            "    int size() { return tr.size(); }",
            "    int new_node() { tr.push_back({});return ++sz; }",
            "    void clear() { tr.clear();tr.resize(1);sz=0; }",
            "",
            "    AhoCorasickAutomaton() { tr.resize(1); }",
            "    AhoCorasickAutomaton(int sz) { tr.reserve(sz+1);tr.push_back({}); }",
            "} acam;"
        ],
        "description": "Aho-Corasick Automaton",
        "prefix": "#acam"
    },
    "[String] Aho-Corasick Automaton with Fail Tree": {
        "body": [
            "struct AhoCorasickAutomaton {",
            "    constexpr static int A=26;",
            "    constexpr static char B='a';",
            "    struct Node {",
            "        int link,cnt;",
            "        int ch[A];",
            "        vector<int> adj;",
            "    };",
            "",
            "    vector<Node> tr;",
            "    vector<int> id,ed;",
            "    int sz=0,idx=0;",
            "",
            "    int insert(string &s) {",
            "        int root=0;",
            "        for(auto x:s) {",
            "            int c=x-B;",
            "            if(!tr[root].ch[c]) ",
            "                tr[root].ch[c]=new_node();",
            "            root=tr[root].ch[c];",
            "        }",
            "        tr[root].cnt++;",
            "        return root;",
            "    }",
            "",
            "    void build() {",
            "        queue<int> q;",
            "        for(int i=0;i<A;i++) ",
            "            if(tr[0].ch[i]) {",
            "                q.push(tr[0].ch[i]);",
            "                tr[0].adj.push_back(tr[0].ch[i]);",
            "",
            "            }",
            "        while(q.size()) {",
            "            auto root=q.front();",
            "            q.pop();",
            "            for(int i=0;i<A;i++) {",
            "                int &cur=tr[root].ch[i];",
            "                int pre=tr[tr[root].link].ch[i];",
            "                if(!cur) cur=pre;",
            "                else {",
            "                    // tr[cur].cnt+=tr[pre].cnt;",
            "                    tr[cur].link=pre;",
            "                    tr[pre].adj.push_back(cur);",
            "                    q.push(cur);",
            "                }",
            "            }",
            "        }",
            "",
            "        id.resize(size());",
            "        ed.resize(size());",
            "        relabel(0);",
            "    }",
            "",
            "    void relabel(int u) {",
            "        id[u]=++idx;",
            "        for(int v:tr[u].adj) relabel(v);",
            "        ed[u]=idx;",
            "    }",
            "    ",
            "    int match() {",
            "",
            "    }",
            "",
            "    int size() { return tr.size(); }",
            "    int new_node() { tr.push_back({});return ++sz; }",
            "    void clear() { tr.clear();tr.resize(1);sz=idx=0; }",
            "",
            "    AhoCorasickAutomaton() { tr.resize(1); }",
            "    AhoCorasickAutomaton(int sz) { tr.reserve(sz+1);tr.push_back({}); }",
            "} acam;"
        ],
        "description": "Aho-Corasick Automaton with fail tree",
        "prefix": "#acam_fail"
    },
    "[String] Double End Palindrome Automaton": {
        "body": [
            "struct PalindromeAutomaton {",
            "    constexpr static int A=26;",
            "    constexpr static char B='a';",
            "    struct Node {",
            "        int len,link;",
            "        int cnt;",
            "        int ch[A];",
            "    };",
            "    vector<Node> node;",
            "    deque<char> str;",
            "    int last_l,last_r;",
            "",
            "    int new_node(int len) {",
            "        node.push_back({len});",
            "        return node.size()-1;",
            "    }",
            "    ",
            "    void clear() {",
            "        node.clear();",
            "        last_l=last_r=0;",
            "        str.clear();",
            "        new_node(0);",
            "        new_node(-1);",
            "        node[0].link=1;",
            "    }",
            "",
            "    template<typename T> void extend(char x,int &last,T getfail) {",
            "        int c=x-B;",
            "        int pre=getfail(last);",
            "        if(!node[pre].ch[c]) {",
            "            int cur=new_node(node[pre].len+2);",
            "            node[cur].link=node[getfail(node[pre].link)].ch[c];",
            "            node[pre].ch[c]=cur;",
            "        }",
            "        last=node[pre].ch[c];",
            "        if(node[last].len==str.size()) last_l=last_r=last;",
            "        node[last].cnt++;",
            "    }",
            "",
            "    void extend_l(char x) {",
            "        str.push_front(x);",
            "        extend(x, last_l, [&](int x) {",
            "            int n=int(str.size())-1;",
            "            while(node[x].len+1>n||str[node[x].len+1]!=str[0]) x=node[x].link;",
            "            return x;",
            "        });",
            "    }",
            "",
            "    void extend_r(char x) {",
            "        str.push_back(x);",
            "        extend(x, last_r, [&](int x) {",
            "            int n=int(str.size())-1;",
            "            while(n-node[x].len-1<0||str[n-node[x].len-1]!=str[n]) x=node[x].link;",
            "            return x;",
            "        });",
            "    }",
            "",
            "    int size() { return node.size(); }",
            "",
            "    PalindromeAutomaton() { clear(); }",
            "    PalindromeAutomaton(int sz) { node.reserve(sz),clear(); }",
            "} pam;"
        ],
        "description": "Double-ended Palindrome Automaton",
        "prefix": "#depam"
    },
    "[String] General Suffix Automaton (offline)": {
        "body": [
            "struct GeneralSuffixAutomaton {",
            "    constexpr static int A=26;",
            "    constexpr static char B='a';",
            "    using Arr=array<int, A>;",
            "    struct Endpos {",
            "        int link,len;",
            "        Arr ch;",
            "    };",
            "    vector<Arr> tr;",
            "    vector<Endpos> edp;",
            "",
            "    int new_tr() { tr.push_back({}); return tr.size()-1; }",
            "    int new_edp() { edp.push_back({}); return edp.size()-1; }",
            "",
            "    int split(int p,int c,int len) {",
            "        int q=edp[p].ch[c];",
            "        if(edp[q].len==len) return q;",
            "        else {",
            "            int clone=new_edp();",
            "            edp[clone]=edp[q];",
            "            edp[clone].len=len;",
            "            edp[q].link=clone;",
            "            for(;p!=-1&&edp[p].ch[c]==q;p=edp[p].link)",
            "                edp[p].ch[c]=clone;",
            "            return clone;",
            "        }",
            "    }",
            "",
            "    int extend(int p,int c) {",
            "        int cur=new_edp();",
            "        edp[cur].len=edp[p].len+1;",
            "        for(;p!=-1&&!edp[p].ch[c];p=edp[p].link)",
            "            edp[p].ch[c]=cur;",
            "        if(p!=-1) edp[cur].link=split(p, c, edp[p].len+1);",
            "        return cur;",
            "    }",
            "",
            "    void insert(string &s) {",
            "        int t=0,c=0;",
            "        for(auto x:s) {",
            "            c=x-B;",
            "            if(!tr[t][c]) tr[t][c]=new_tr();",
            "            t=tr[t][c];",
            "        }",
            "    }",
            "",
            "    void build() {",
            "        queue<pair<int,int>> q;",
            "        q.emplace(0,0);",
            "        while(q.size()) {",
            "            auto [t,p]=q.front();",
            "            q.pop();",
            "            for(int c=0;c<A;c++) if(tr[t][c]) ",
            "                q.emplace(tr[t][c],extend(p, c));",
            "        }",
            "    }",
            "",
            "    int size() { return edp.size(); }",
            "",
            "    void clear() {",
            "        edp.clear(),edp.push_back({-1});",
            "        tr.clear(),tr.push_back({});",
            "    }",
            "    ",
            "    GeneralSuffixAutomaton(int sz=0) { edp.reserve(sz),tr.reserve(sz),clear(); }",
            "} sam;"
        ],
        "description": "General Suffix Automaton (offline version, with trie)",
        "prefix": "#gsam_offline_trie"
    },
    "[String] General Suffix Automaton (offline, without trie)": {
        "body": [
            "struct GeneralSuffixAutomaton {",
            "    constexpr static int A=26;",
            "    constexpr static char B='a';",
            "    using Arr=array<int, A>;",
            "    struct Endpos {",
            "        int link,len;",
            "        Arr ch;",
            "    };",
            "    vector<Endpos> edp;",
            "",
            "    int new_edp() { edp.push_back({}); return edp.size()-1; }",
            "",
            "    int split(int p,int c,int len) {",
            "        int q=edp[p].ch[c];",
            "        if(edp[q].len==len) return q;",
            "        else {",
            "            int clone=new_edp();",
            "            edp[clone]=edp[q];",
            "            edp[clone].len=len;",
            "            edp[q].link=clone;",
            "            for(;p!=-1&&edp[p].ch[c]==q;p=edp[p].link)",
            "                edp[p].ch[c]=clone;",
            "            return clone;",
            "        }",
            "    }",
            "",
            "    void extend(int p,int c) {",
            "        int cur=edp[p].ch[c];",
            "        edp[cur].len=edp[p].len+1;",
            "        for(;p!=-1&&(edp[p].ch[c]==cur||!edp[p].ch[c]);p=edp[p].link)",
            "            edp[p].ch[c]=cur;",
            "        if(p!=-1) edp[cur].link=split(p, c, edp[p].len+1);",
            "    }",
            "",
            "    void insert(string &s) {",
            "        int t=0,c=0;",
            "        for(auto x:s) {",
            "            c=x-B;",
            "            if(!edp[t].ch[c]) edp[t].ch[c]=new_edp();",
            "            t=edp[t].ch[c];",
            "        }",
            "    }",
            "",
            "    void build() {",
            "        queue<int> q;",
            "        q.push(0);",
            "        while(q.size()) {",
            "            int p=q.front();",
            "            q.pop();",
            "            for(int c=0;c<A;c++) if(edp[p].ch[c]) ",
            "                extend(p, c),q.push(edp[p].ch[c]);",
            "        }",
            "    }",
            "",
            "    int size() { return edp.size(); }",
            "    void clear() { edp.clear(),edp.push_back({-1}); }",
            "    ",
            "    GeneralSuffixAutomaton(int sz=0) { edp.reserve(sz),clear(); }",
            "} sam;"
        ],
        "description": "General Suffix Automaton (offline version, without trie)",
        "prefix": "#gsam_offline"
    },
    "[String] General Suffix Automaton (online)": {
        "body": [
            "struct GeneralSuffixAutomaton {",
            "    constexpr static int A=26;",
            "    constexpr static char B='a';",
            "    using Arr=array<int, A>;",
            "    struct Endpos {",
            "        int link,len;",
            "        Arr ch;",
            "    };",
            "    vector<Arr> tr;",
            "    vector<Endpos> edp;",
            "",
            "    int new_tr() { tr.push_back({}); return tr.size()-1; }",
            "    int new_edp() { edp.push_back({}); return edp.size()-1; }",
            "",
            "    int split(int p,int c,int len) {",
            "        int q=edp[p].ch[c];",
            "        if(edp[q].len==len) return q;",
            "        else {",
            "            int clone=new_edp();",
            "            edp[clone]=edp[q];",
            "            edp[clone].len=len;",
            "            edp[q].link=clone;",
            "            for(;p!=-1&&edp[p].ch[c]==q;p=edp[p].link)",
            "                edp[p].ch[c]=clone;",
            "            return clone;",
            "        }",
            "    }",
            "",
            "    void extend(int &p,int &t,char x,int len) {",
            "        int c=x-B;",
            "        int last;",
            "        if(tr[t][c]) last=edp[p].ch[c];",
            "        else {",
            "            tr[t][c]=new_tr();",
            "            if(edp[p].ch[c]) last=split(p, c, len);",
            "            else {",
            "                int cur=last=new_edp();",
            "                edp[cur].len=len;",
            "                for(;p!=-1&&!edp[p].ch[c];p=edp[p].link)",
            "                    edp[p].ch[c]=cur;",
            "                if(p!=-1) edp[cur].link=split(p, c, edp[p].len+1);",
            "            }",
            "        }",
            "        t=tr[t][c];",
            "        p=last;",
            "    }",
            "",
            "    void insert(string &s) {",
            "        for(int p=0,t=0,i=0;i<s.size();i++) extend(p, t, s[i], i+1);",
            "    }",
            "",
            "    int size() { return edp.size(); }",
            "    ",
            "    void clear() {",
            "        edp.clear(),edp.push_back({-1});",
            "        tr.clear(),tr.push_back({});",
            "    }",
            "    ",
            "    GeneralSuffixAutomaton(int sz=0) { edp.reserve(sz),tr.reserve(sz),clear(); }",
            "} sam;"
        ],
        "description": "General Suffix Automaton (online version)",
        "prefix": "#gsam"
    },
    "[String] KMP": {
        "body": [
            "void kmp_build(int n) {",
            "    for(int i=2,j=0;i<=n;i++) {",
            "        while(j&&t[i]!=t[j+1]) j=link[j];",
            "        if(t[i]==t[j+1]) j++;",
            "        link[i]=t[i+1]==t[j+1]?link[j]:j; ",
            "    }",
            "}"
        ],
        "description": "KMP",
        "prefix": "#kmp"
    },
    "[String] Palindrome Automaton": {
        "body": [
            "struct PalindromeAutomaton {",
            "    constexpr static int A=26;",
            "    constexpr static char B='a';",
            "    struct Node {",
            "        int len,link;",
            "        int cnt;",
            "        int ch[A];",
            "    };",
            "    vector<Node> node;",
            "    string str;",
            "    int last;",
            "",
            "    int new_node(int len) {",
            "        node.push_back({len});",
            "        return node.size()-1;",
            "    }",
            "    ",
            "    void clear() {",
            "        node.clear();",
            "        last=0;",
            "        str=\"!\";",
            "        new_node(0);",
            "        new_node(-1);",
            "        node[0].link=1;",
            "    }",
            "",
            "    int getfail(int x) {",
            "        while(str[str.size()-node[x].len-2]!=str.back()) x=node[x].link;",
            "        return x;",
            "    }",
            "",
            "    void extend(char x) {",
            "        str.push_back(x);",
            "        int c=x-B;",
            "        int pre=getfail(last);",
            "        if(!node[pre].ch[c]) {",
            "            int cur=new_node(node[pre].len+2);",
            "            node[cur].link=node[getfail(node[pre].link)].ch[c];",
            "            node[pre].ch[c]=cur;",
            "        }",
            "        last=node[pre].ch[c];",
            "        node[last].cnt++;",
            "    }",
            "",
            "    void build(string &s) { for(auto x:s) extend(x); }",
            "    int size() { return node.size(); }",
            "",
            "    PalindromeAutomaton() { clear(); }",
            "    PalindromeAutomaton(int sz) { str.reserve(sz),node.reserve(sz),clear(); }",
            "} pam;"
        ],
        "description": "Palindrome Automaton",
        "prefix": "#pam"
    },
    "[String] Suffix Array": {
        "body": [
            "constexpr int N=${1:1e6+10};",
            "",
            "int n,m=1<<7;",
            "string s;",
            "int fir[N],sec[N],cnt[N];",
            "int sa[N],rk[N],height[N];",
            "",
            "void get_sa() {",
            "    for(int i=1;i<=n;i++) cnt[fir[i]=s[i]]++;",
            "    for(int i=2;i<=m;i++) cnt[i]+=cnt[i-1];",
            "    for(int i=n;i;i--) sa[cnt[fir[i]]--]=i;",
            "",
            "    for(int k=1;k<=n;k<<=1) {",
            "        int num=0;",
            "        for(int i=n-k+1;i<=n;i++) sec[++num]=i;",
            "        for(int i=1;i<=n;i++) if(sa[i]>k) sec[++num]=sa[i]-k;",
            "        for(int i=1;i<=m;i++) cnt[i]=0;",
            "        for(int i=1;i<=n;i++) cnt[fir[i]]++;",
            "        for(int i=2;i<=m;i++) cnt[i]+=cnt[i-1];",
            "        for(int i=n;i;i--) sa[cnt[fir[sec[i]]]--]=sec[i],sec[i]=0;",
            "        swap(fir,sec);",
            "        fir[sa[1]]=num=1;",
            "        for(int i=2;i<=n;i++)",
            "            fir[sa[i]]=(sec[sa[i]]==sec[sa[i-1]]&&sec[sa[i]+k]==sec[sa[i-1]+k])",
            "                ?num:++num;",
            "        if(num==n) break;",
            "        m=num;",
            "    }",
            "}",
            "",
            "void get_height() {",
            "    for(int i=1;i<=n;i++) rk[sa[i]]=i;",
            "    for(int i=1,k=0;i<=n;i++) {",
            "        if(rk[i]==1) continue;",
            "        if(k) k--;",
            "        int j=sa[rk[i]-1];",
            "        while(i+k<=n&&j+k<=n&&s[i+k]==s[j+k]) k++;",
            "        height[rk[i]]=k;",
            "    }",
            "}"
        ],
        "description": "倍增法求后缀数组 O(nlogn)",
        "prefix": "#sa"
    },
    "[String] Suffix Automaton": {
        "body": [
            "struct SuffixAutomaton {",
            "    constexpr static int A=26;",
            "    constexpr static char B='a';",
            "    struct Endpos {",
            "        int link,len,cnt;",
            "        int ch[A];",
            "    };",
            "    vector<Endpos> edp;",
            "    int last=0;",
            "",
            "    int new_node() {",
            "        edp.push_back({});",
            "        return edp.size()-1;",
            "    }",
            "",
            "    void extend(char x) {",
            "        int c=x-B;",
            "        int p=last;",
            "        int cur=last=new_node();",
            "        edp[cur].len=edp[p].len+1;",
            "        for(;p!=-1&&!edp[p].ch[c];p=edp[p].link) edp[p].ch[c]=cur;",
            "        if(p!=-1) {",
            "            int q=edp[p].ch[c];",
            "            if(edp[p].len+1==edp[q].len) edp[cur].link=q;",
            "            else {",
            "                int clone=new_node();",
            "                edp[clone]=edp[q];",
            "                edp[clone].len=edp[p].len+1; ",
            "                edp[cur].link=edp[q].link=clone;",
            "                for(;p!=-1&&edp[p].ch[c]==q;p=edp[p].link) ",
            "                    edp[p].ch[c]=clone;",
            "            }",
            "        }",
            "    }",
            "",
            "    int size() { return edp.size(); }",
            "    void build(const string &s) { for(auto x:s) extend(x); }",
            "    void clear() { edp.clear(),edp.push_back({-1}),last=0; }",
            "    ",
            "    SuffixAutomaton(int sz=0) { edp.reserve(sz),clear(); }",
            "    SuffixAutomaton(const string &s) { edp.reserve(s.size()*2),clear(),build(s); }",
            "} sam;"
        ],
        "description": "Suffix Automaton",
        "prefix": "#sam"
    },
    "[String] Suffix Automaton Count": {
        "body": [
            "void count(const string &s) {",
            "    int u=0;",
            "    for(auto x:s) {",
            "        int c=x-B;",
            "        u=edp[u].ch[c];",
            "        edp[u].cnt++;",
            "    }",
            "    for(int u:toporder) {",
            "        int p=edp[u].link;",
            "        edp[p].cnt+=edp[u].cnt;",
            "    }",
            "}"
        ],
        "description": "SAM子串出现次数",
        "prefix": "#sam_cnt"
    },
    "[String] Suffix Automaton Endpos Maintaining": {
        "body": [
            "int root[N*2];",
            "struct MergeableSegmentTree {",
            "",
            "    #define lch (tr[u].lc)",
            "    #define rch (tr[u].rc)",
            "    constexpr static int MAX_SIZE=N*80;",
            "    constexpr static int pos_l=0,pos_r=N-1;",
            "    ",
            "    struct Node {",
            "        int lc,rc;",
            "        int cnt;",
            "    } tr[MAX_SIZE];",
            "    int idx;",
            "",
            "    int new_node() { return ++idx; }",
            "",
            "    int merge(int x,int y) {",
            "        if(!x||!y) return x|y;",
            "        int u=new_node();",
            "        lch=merge(tr[x].lc,tr[y].lc);",
            "        rch=merge(tr[x].rc,tr[y].rc);",
            "        tr[u].cnt=tr[lch].cnt+tr[rch].cnt;",
            "        return u;",
            "    }",
            "",
            "    int __query(int u,int l,int r,int ql,int qr) {",
            "        if(l>=ql&&r<=qr) return tr[u].cnt;",
            "        int mid=l+r>>1;",
            "        int res=0;",
            "        if(lch&&mid>=ql) res+=__query(lch, l, mid, ql, qr);",
            "        if(rch&&mid<qr) res+=__query(rch, mid+1, r, ql, qr);",
            "        return res;",
            "    }",
            "",
            "    int query(int u,int ql,int qr) {",
            "        if(ql>qr) return 0;",
            "        return __query(u, pos_l, pos_r, ql, qr);",
            "    }",
            "",
            "    void __build(int &u,int l,int r,int p) {",
            "        u=new_node();",
            "        tr[u].cnt=1;",
            "        if(l!=r) {",
            "            int mid=l+r>>1;",
            "            if(p<=mid) __build(lch,l,mid,p);",
            "            else __build(rch,mid+1,r,p);",
            "        }",
            "    }",
            "",
            "    void build(int &u,int p) { __build(u, pos_l, pos_r, p); }",
            "",
            "    #undef lch",
            "    #undef rch",
            "",
            "} sgt;",
            "",
            "void build_sgt(string &s) {",
            "    for(int u=0,i=0;i<s.size();i++) {",
            "        int c=s[i]-B;",
            "        u=edp[u].ch[c];",
            "        sgt.build(root[u], i);",
            "    }",
            "    for(int u:toporder) {",
            "        int p=edp[u].link;",
            "        if(p) root[p]=sgt.merge(root[p], root[u]);",
            "    }",
            "}",
            "",
            "auto query(int l,int r,int L,int R) {",
            "    int len=r-l+1;",
            "    int u=lca::find(l,r);",
            "    return sgt.query(root[u],L+len-1,R);",
            "}"
        ],
        "description": "线段树合并维护SAM endpos集合",
        "prefix": "#sam_sgt"
    },
    "[String] Suffix Automaton LCA": {
        "body": [
            "// * index start from 0",
            "namespace lca {",
            "    const auto &edp=sam.edp;",
            "    constexpr int M=__lg(N*2);",
            "    int fa[N*2][M+1],dep[N*2],pos[N];",
            "",
            "    void get_fa(const vector<int> &q) {",
            "        dep[0]=1;",
            "        for(auto it=q.rbegin();it!=q.rend();it++) {",
            "            int u=*it;",
            "            int p=edp[u].link;",
            "            dep[u]=dep[p]+1;",
            "            fa[u][0]=p;",
            "            for(int i=1;i<=M;i++) fa[u][i]=fa[fa[u][i-1]][i-1];",
            "        }",
            "    }",
            "",
            "    void get_pos(const string &s) {",
            "        int u=0;",
            "        for(int i=0;i<s.size();i++) {",
            "            int c=s[i]-sam.B;",
            "            u=edp[u].ch[c];",
            "            pos[i]=u;",
            "        }",
            "    }",
            "",
            "    int find(int l,int r) {",
            "        int u=pos[r];",
            "        int len=r-l+1;",
            "        for(int i=M;i>=0;i--) {",
            "            int p=fa[u][i];",
            "            if(edp[p].len>=len) u=p;",
            "        }",
            "        return u;",
            "    }",
            "",
            "    int lca(int u,int v) {",
            "        if(dep[u]<dep[v]) swap(u,v);",
            "        for(int k=M;~k;k--)",
            "            if(dep[fa[u][k]]>=dep[v])",
            "                u=fa[u][k];",
            "        if(u==v) return u;",
            "        for(int k=M;~k;k--)",
            "            if(fa[u][k]!=fa[v][k])",
            "                u=fa[u][k],v=fa[v][k];",
            "        return fa[u][0];",
            "    }",
            "",
            "    int lcs(int l,int r,int L,int R) {",
            "        int u=find(l,r),v=find(L,R);",
            "        if(u==v) return min(r-l+1,R-L+1);",
            "        int p=lca(u,v);",
            "        return edp[p].len;",
            "    }",
            "}"
        ],
        "description": [
            "parent树上倍增\n",
            "find(l,r) 定位串[l,r]在sam上的位置\n",
            "max_suf(l,r) 计算串[l,r]与[L,R]的最长公共后缀\n",
            "下标均从0开始"
        ],
        "prefix": "#sam_lca"
    },
    "[String] Suffix Automaton Toporder": {
        "body": [
            "vector<int> toporder;",
            "void toposort() {",
            "    auto &q=toporder;",
            "    q.clear();",
            "    q.reserve(size());",
            "    vector<int> ind(size());",
            "    for(int i=1;i<size();i++) ind[edp[i].link]++;",
            "    for(int i=1;i<size();i++) if(!ind[i]) q.push_back(i);",
            "    for(int i=0;i<q.size();i++) {",
            "        int u=q[i];",
            "        int p=edp[u].link;",
            "        if(p&&!--ind[p]) q.push_back(p);",
            "    }",
            "}"
        ],
        "description": "SAM拓扑序",
        "prefix": "#sam_top"
    }
}