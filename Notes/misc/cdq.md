# CDQ分治

> [OI-wiki](https://oi-wiki.org/misc/cdq-divide/)

cdq分治用来解决三维偏序问题，在应用cdq分治解题时，通常是将问题转化为三维偏序来解决。

## 三维偏序

> [AcWing](https://www.acwing.com/problem/content/2817/)

类似归并求逆序对，每次解决两段间的信息合并，由于每层需要维护一个树状数组，所以时间复杂度为$O(n\log^2 n)$。

需要注意的是，三维偏序若存在完全相同的点，则需要特殊处理，这也是所有应用cdq分治都需要注意的地方。

# 直接应用

## 老C的任务 

> [AcWing](https://www.acwing.com/problem/content/2849/)

本质为带权值的二维数点。可以离线询问+树状数组来解决，或者转化为三维偏序问题：

首先利用二维前缀和的技巧将1个区间询问拆分为4个前缀询问，为了区分是数据点还是询问点，引入一个新的量$z$表示类型，$z=1$表示询问点，$z=0$表示数据点。

然后就可以得到三个偏序关系：

- 横坐标 $x_i < x_j$
- 纵坐标 $y_i < y_j$
- 类型 $z_i < z_j$

但是由于$z$仅有0和1，所以不需要额外维护一个数组数组，时间复杂度$O(n\log n)$。

## 动态逆序对 

> [AcWing](https://www.acwing.com/problem/content/2821/)

带删除的逆序对问题，尝试构造出三维偏序。

首先很显然已知两维：下标和权值。然后再利用顺序删除问题的一个技巧：将时间戳作为第三维（对于未删除的元素，将其任意赋值一个唯一的$>m$的时间戳即可），如此就得到了三维偏序。

对于$j$左边的点：

- $i < j$
- $A_i > A_j$
- $T_i > T_j$

对于$j$右边的点：

- $i > j$
- $A_i < A_j$
- $T_i > T_j$

为了方便复用函数，将序列反转后，偏序关系变为：

- $i < j$
- $A_i > A_j$
- $T_i > T_j$

注意时间戳的偏序关系是不变的。

维护一个数组$ans$和时间戳索引的树状数组，对于$i$号点，计算树状数组的后缀和作为贡献加到$ans[T_i]$中，再对$ans$求后缀和即为答案。时间复杂度$O(n\log^2n)$。

## [USACO04OPEN] MooFest G

> [luogu](https://www.luogu.com.cn/problem/P5094)

类似上题，正反做两边分治：

- $x_i < x_j$ 且 $v_i <= v_j$
- $x_i > x_j$ 且 $v_i < v_j$ （注意遍免重复统计）
  - 将序列翻转后：$x_i < x_j$ 且 $v_i < v_j$

由于仅存在两维偏序，不需要树状数组，维护两个变量：下标和与个数即可，时间复杂度$O(n\log n)$。

注意存在完全相同的点，需要按照双关键字排序。

## [Violet]天使玩偶/SJY摆棋子 

> [luogu](https://www.luogu.com.cn/problem/P4169)

这道题可以大致看作[动态逆序对](#动态逆序对)和[老C的任务](#老c的任务)的缝合。

按照$x,y$的大小关系暴力分四类讨论，最简单的情形是：

- $x_i < x_j$
- $y_i < y_j$
- $T_i < T_j$
- $type_i < type_j$

维护一颗按$T$索引的树状数组，维护$x+y$的最大值。

而对于其他三种情形，我们可以仿照前面的套路，将点按照对应的顺序反转后再跑cdq。

- $x_i < x_j$ 且 $y_i > y_j$ 上下反转
- $x_i > x_j$ 且 $y_i < y_j$ 左右反转
- $x_i > x_j$ 且 $y_i > y_j$ 上下反转+左右反转

由于求最小值而不是计数，所以不需要关心相同点问题，但是需要注意树状数组的初始值应设为负无穷，时间复杂度$O(n\log^2n)$。

# CDQ 分治优化 1D/1D 动态规划的转移

具体参见[OI-wiki](https://oi-wiki.org/misc/cdq-divide/#%E8%BD%AC%E7%A7%BB%E8%BF%87%E7%A8%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E)的这部分，写的非常详细。

## [SDOI2011]拦截导弹

> [luogu]([SDOI2011]拦截导弹 )

二维版本的最长上升子序列。可以直接列出dp转移方程：

$$
dp_j=1+\max_{i=1}^{j-1}dp_i \text{ if } h_i<h_j \text{ and } v_i<v_j
$$

直接转移显然是$O(n^2)$的，观察到转移过程其实也是点对之间的关系，使用CDQ分治优化转移过程。

设当前区间为$[L,R]$

- 若$L=R$，那么$[1,L)$已经处理完成，我们直接令$dp_L:=dp_L+1$即可
- 递归处理$[L,mid]$
- 像一般的CDQ分治一样处理$[L,mid]$与$[mid+1,R]$的信息合并
- 递归处理$[mid+1,R]$

和一般的CDQ分治最大的区别是，我们不直接递归左右两边，而是变成了左->中->右的顺序，这主要是为了保证dp转移顺序的正确性。

回到问题，现在除了要计算最长长度外，还需要计算概率。解决方法为：维护两个dp值， $len_i$ 表示以 $i$ 点结束的最长序列长度，$cnt_i$ 表示 $i$ 这样的序列有多少个。

为了方便统计，在原序列末尾追加一个 $h=0,v=0$ 的点，这样处理后每个 $\text{LIS}$ 都会以这个点结束。正着跑一次 $\text{LIS}$ 的CDQ，再反着跑一次 $\text{LDS}$ 的CDQ，得到每个点前后缀的 $len/cnt$。

所求的 $\text{LIS}$ 的长度就是 $len_{n+1}-1$，不同的 $\text{LIS}$ 数量为 $cnt_{n+1}$。若一个点 $i$ 满足 $pre\_len_i+suf\_len_i-1=len_{n+1}-1$，那么这个点是一个合法的点，出现的概率为覆盖 $i$ 的序列数除以总序列数 $\frac{pre\_cnt_isuf\_cnt_i}{cnt_{n+1}}$。

注意 $cnt$ 会爆 `int64`，应使用浮点数存储。